// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

// Tests for user-defined error subclasses (BT-480)
// Verifies that custom Exception subclasses can be created, signaled,
// and caught with proper class hierarchy matching.

// @load tests/e2e/fixtures/custom_error.bt

// ===========================================================================
// SIGNAL FROM USER-DEFINED EXCEPTION CLASS
// ===========================================================================

// signal: on custom error raises with correct class
[MyCustomError new signal: 'oops'] on: Exception do: [:e | e class]
// => MyCustomError

// signal (no args) on custom error raises with class name as message
[MyCustomError new signal] on: Exception do: [:e | e class]
// => MyCustomError

// signal (no args) message is the class name
[MyCustomError new signal] on: Exception do: [:e | e message]
// => MyCustomError

// signal: preserves the message
[MyCustomError new signal: 'custom message'] on: Exception do: [:e | e message]
// => custom message

// signal preserves kind as 'signal'
[MyCustomError new signal: 'test'] on: Exception do: [:e | e kind]
// => signal

// ===========================================================================
// CATCHING BY EXACT CLASS
// ===========================================================================

// on: MyCustomError do: catches MyCustomError
[MyCustomError new signal: 'caught'] on: MyCustomError do: [:e | e message]
// => caught

// ===========================================================================
// CATCHING BY PARENT CLASS (HIERARCHY)
// ===========================================================================

// on: Error do: catches MyCustomError (Error is superclass)
[MyCustomError new signal: 'err'] on: Error do: [:e | 'caught by Error']
// => caught by Error

// on: Exception do: catches MyCustomError (Exception is root)
[MyCustomError new signal: 'exc'] on: Exception do: [:e | 'caught by Exception']
// => caught by Exception

// ===========================================================================
// NON-MATCHING CLASSES
// ===========================================================================

// on: TypeError do: does NOT catch MyCustomError
[[MyCustomError new signal: 'no'] on: TypeError do: [:e | 'wrong']] on: Exception do: [:e | 'correct']
// => correct

// on: RuntimeError do: does NOT catch MyCustomError
[[MyCustomError new signal: 'no'] on: RuntimeError do: [:e | 'wrong']] on: Exception do: [:e | 'correct']
// => correct

// ===========================================================================
// BUILT-IN ERRORS STILL WORK CORRECTLY
// ===========================================================================

// Built-in does_not_understand still maps to RuntimeError
[42 noSuchMethod] on: RuntimeError do: [:e | e class]
// => RuntimeError

// Built-in type_error still maps to TypeError
[#(1, 2, 3) at: 'hello'] on: TypeError do: [:e | e class]
// => TypeError

// MyCustomError does NOT catch built-in RuntimeError
[[42 noSuchMethod] on: MyCustomError do: [:e | 'wrong']] on: Exception do: [:e | 'correct']
// => correct

// ===========================================================================
// RE-SIGNALING CAUGHT EXCEPTIONS
// ===========================================================================

// Re-signaling a caught custom exception preserves its class
[[MyCustomError new signal: 're-test'] on: MyCustomError do: [:e | e signal: 'forwarded']] on: MyCustomError do: [:e | e message]
// => forwarded
