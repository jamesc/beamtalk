// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

// BT-761: Non-local return (^) inside block arguments in Actor subclass methods.
//
// @load tests/e2e/fixtures/actor_nlr_basic.bt
// @load tests/e2e/fixtures/actor_nlr_local_var.bt
// @load tests/e2e/fixtures/actor_nlr_computed.bt
// @load tests/e2e/fixtures/actor_nlr_on_do.bt
// @load tests/e2e/fixtures/actor_nlr_recursive.bt
// @load tests/e2e/fixtures/actor_nlr_mutate.bt

// === ifTrue: with non-local return ===

a := ActorNlrBasic spawn
// => #Actor<ActorNlrBasic,_>

(a test: #()) await
// => empty

(a test: #(1)) await
// => not empty

// === ifTrue:ifFalse: with non-local returns in both branches ===

(a classify: 5) await
// => positive

(a classify: -1) await
// => non-positive

(a classify: 0) await
// => non-positive

// === ifFalse: with non-local return ===

(a checkFalse: #()) await
// => empty

(a checkFalse: #(1)) await
// => not empty

// === Local variable + NLR ===

b := ActorNlrLocalVar spawn
// => #Actor<ActorNlrLocalVar,_>

(b store: "x" val: 42) await
// => _

(b fetch: "x") await
// => 42

(b fetch: "y") await
// => not found

// === NLR with computed return value ===

c := ActorNlrComputed spawn
// => #Actor<ActorNlrComputed,_>

(c doubleIfPositive: 5) await
// => 10

(c doubleIfPositive: -1) await
// => 0

// === NLR in recursive Actor method ===

d := ActorNlrRecursive spawn
// => #Actor<ActorNlrRecursive,_>

(d countDown: 3) await
// => done

(d countDown: 0) await
// => done

// === NLR propagates through on:do: (not swallowed) ===

e := ActorNlrOnDo spawn
// => #Actor<ActorNlrOnDo,_>

(e test: #()) await
// => early

(e test: #(1)) await
// => not early

// === NLR after field mutation preserves updated state ===

f := ActorNlrMutate spawn
// => #Actor<ActorNlrMutate,_>

// count starts at 0; incAndCheck: 1 sets count=1, 1>=1 triggers NLR
(f incAndCheck: 1) await
// => 1

// count is now 1 (mutation was preserved); incAndCheck: 5 sets count=2, 2<5 falls through
(f incAndCheck: 5) await
// => not yet

// count is now 2; incAndCheck: 3 sets count=3, 3>=3 triggers NLR
(f incAndCheck: 3) await
// => 3

// count is now 3 (verified mutation persisted across NLR and non-NLR paths)
(f incAndCheck: 10) await
// => not yet
