// Stream — constructors, lazy pipeline, terminals
// BT-511: Phase 1 of ADR 0021

// === Constructors ===

// Stream from: — infinite successor stream
(Stream from: 1) take: 5
// => [1,2,3,4,5]

(Stream from: 10) take: 3
// => [10,11,12]

(Stream from: 0) take: 1
// => [0]

(Stream from: -3) take: 4
// => [-3,-2,-1,0]

// Stream from:by: — step function stream
(Stream from: 1 by: [:n | n * 2]) take: 5
// => [1,2,4,8,16]

(Stream from: 0 by: [:n | n + 10]) take: 4
// => [0,10,20,30]

(Stream from: 100 by: [:n | n - 1]) take: 3
// => [100,99,98]

// Stream on: — from collection
(Stream on: #(1, 2, 3)) asList
// => [1,2,3]

(Stream on: #()) asList
// => []

(Stream on: #(42)) asList
// => [42]

// === Lazy Operations ===

// select: — filter
((Stream on: #(1, 2, 3, 4, 5)) select: [:n | n > 3]) asList
// => [4,5]

((Stream on: #(1, 2, 3, 4, 5, 6)) select: [:n | n isEven]) asList
// => [2,4,6]

// select: on empty
((Stream on: #()) select: [:n | n > 0]) asList
// => []

// collect: — transform
((Stream on: #(1, 2, 3)) collect: [:n | n * 10]) asList
// => [10,20,30]

((Stream on: #(1, 2, 3)) collect: [:n | n + 100]) asList
// => [101,102,103]

// reject: — inverse filter
((Stream on: #(1, 2, 3, 4, 5)) reject: [:n | n > 3]) asList
// => [1,2,3]

((Stream on: #(1, 2, 3, 4)) reject: [:n | n isEven]) asList
// => [1,3]

// drop: — skip first N
((Stream on: #(1, 2, 3, 4, 5)) drop: 2) asList
// => [3,4,5]

((Stream on: #(1, 2, 3)) drop: 0) asList
// => [1,2,3]

((Stream on: #(1, 2, 3)) drop: 5) asList
// => []

// === Terminal Operations ===

// take: — first N elements
(Stream from: 1) take: 0
// => []

(Stream from: 1) take: 3
// => [1,2,3]

// take: on finite stream (fewer elements than requested)
(Stream on: #(1, 2)) take: 10
// => [1,2]

// do: — iterate with side effects
(Stream on: #(1, 2, 3)) do: [:n | n]
// => nil

// inject:into: — fold/reduce
(Stream on: #(1, 2, 3, 4)) inject: 0 into: [:sum :n | sum + n]
// => 10

(Stream on: #(1, 2, 3)) inject: 1 into: [:product :n | product * n]
// => 6

(Stream on: #()) inject: 42 into: [:acc :n | acc + n]
// => 42

// detect: — first matching element
(Stream on: #(1, 2, 3, 4, 5)) detect: [:n | n > 3]
// => 4

(Stream on: #(1, 2, 3)) detect: [:n | n > 10]
// => nil

// asList — materialize
(Stream on: #(10, 20, 30)) asList
// => [10,20,30]

// anySatisfy: — any match?
(Stream on: #(1, 2, 3)) anySatisfy: [:n | n > 2]
// => true

(Stream on: #(1, 2, 3)) anySatisfy: [:n | n > 10]
// => false

(Stream on: #()) anySatisfy: [:n | n > 0]
// => false

// allSatisfy: — all match?
(Stream on: #(1, 2, 3)) allSatisfy: [:n | n > 0]
// => true

(Stream on: #(1, 2, 3)) allSatisfy: [:n | n > 2]
// => false

(Stream on: #()) allSatisfy: [:n | n > 0]
// => true

// === Pipeline Composition ===

// Chained lazy ops on infinite stream
((Stream from: 1) select: [:n | n isEven]) take: 5
// => [2,4,6,8,10]

((Stream from: 1) collect: [:n | n * n]) take: 5
// => [1,4,9,16,25]

// Multi-step pipeline
(((Stream from: 1) select: [:n | n isEven]) collect: [:n | n * n]) take: 4
// => [4,16,36,64]

// Pipeline with drop
((Stream from: 1) drop: 5) take: 3
// => [6,7,8]

// inject on finite stream
(Stream on: #(1, 2, 3, 4, 5)) inject: 0 into: [:sum :n | sum + n]
// => 15

// === printString ===

(Stream from: 1) printString
// => Stream(from: 1)

(Stream on: #(1, 2, 3)) printString
// => Stream(on: [...])

// Pipeline description
((Stream from: 1) select: [:n | n isEven]) printString
// => Stream(from: 1) | select: [...]

// === describe ===

(Stream from: 1) describe
// => a Stream

// === class ===

(Stream from: 1) class
// => Stream

// === Empty stream operations ===

(Stream on: #()) take: 5
// => []

(Stream on: #()) asList
// => []

(Stream on: #()) detect: [:x | x > 0]
// => nil

(Stream on: #()) anySatisfy: [:x | x > 0]
// => false

(Stream on: #()) allSatisfy: [:x | x > 0]
// => true

(Stream on: #()) inject: 0 into: [:acc :x | acc + x]
// => 0

// === drop more than available ===

((Stream on: #(1, 2, 3)) drop: 10) asList
// => []

// === Error paths: instance method type errors ===
// Note: constructor error paths (Stream from: "x") cannot be tested in
// stdlib tests due to gen_server calling_self limitation. These are
// validated by the runtime fallback clauses using raise_type_error/2.

(Stream from: 1) select: "not a block"
// => ERROR: type_error

(Stream from: 1) collect: 42
// => ERROR: type_error

(Stream from: 1) take: "five"
// => ERROR: type_error

(Stream from: 1) inject: 0 into: "not a block"
// => ERROR: type_error

(Stream from: 1) detect: 42
// => ERROR: type_error
