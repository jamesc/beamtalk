// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

// Stream — collection stream methods
// BT-514: Phase 3 of ADR 0021

// === List stream ===

// Basic list stream
(#(1, 2, 3) stream) asList
// => [1,2,3]

// Empty list stream
(#() stream) asList
// => []

// Single element
(#(42) stream) asList
// => [42]

// Lazy pipeline on list stream
((#(1, 2, 3, 4, 5) stream) select: [:n | n > 2]) asList
// => [3,4,5]

// Collect on list stream
((#(1, 2, 3) stream) collect: [:n | n * 10]) asList
// => [10,20,30]

// Stream returns Stream, not List
(#(1, 2, 3) stream) class
// => Stream

// Chained lazy pipeline
(((#(1, 2, 3, 4, 5, 6) stream) select: [:n | n > 2]) collect: [:n | n * 10]) asList
// => [30,40,50,60]

// Take on list stream
(#(1, 2, 3, 4, 5) stream) take: 3
// => [1,2,3]

// Inject into on list stream
(#(1, 2, 3) stream) inject: 0 into: [:sum :n | sum + n]
// => 6

// Detect on list stream
(#(1, 2, 3, 4) stream) detect: [:n | n > 2]
// => 3

// anySatisfy on list stream
(#(1, 2, 3) stream) anySatisfy: [:n | n > 2]
// => true

// allSatisfy on list stream
(#(1, 2, 3) stream) allSatisfy: [:n | n > 0]
// => true

// respondsTo: #stream
#(1, 2, 3) respondsTo: #stream
// => true

'hello' respondsTo: #stream
// => true

(Set new) respondsTo: #stream
// => true

#{#a => 1} respondsTo: #stream
// => true

// === String stream ===

// Basic string stream — characters as graphemes
('hello' stream) take: 3
// => ["h","e","l"]

// Full string stream
('abc' stream) asList
// => ["a","b","c"]

// Empty string stream
('' stream) asList
// => []

// Single character
('x' stream) asList
// => ["x"]

// Select on string stream
(('hello' stream) select: [:ch | ch /= 'l']) asList
// => ["h","e","o"]

// Collect on string stream
(('abc' stream) collect: [:ch | ch uppercase]) asList
// => ["A","B","C"]

// String stream returns Stream
('hello' stream) class
// => Stream

// reject on string stream
(('hello' stream) reject: [:ch | ch =:= 'l']) asList
// => ["h","e","o"]

// drop on string stream
(('hello' stream) drop: 3) asList
// => ["l","o"]

// do: on string stream (side effect, returns nil)
('abc' stream) do: [:ch | ch]
// => nil

// inject:into: on string stream
('abc' stream) inject: '' into: [:acc :ch | acc ++ ch]
// => abc

// anySatisfy on string stream
('hello' stream) anySatisfy: [:ch | ch =:= 'e']
// => true

// allSatisfy on string stream
('hello' stream) allSatisfy: [:ch | ch /= 'z']
// => true

// === Set stream ===

// Basic set stream
s := ((Set new add: 3) add: 1) add: 2
// => _

(s stream) asList
// => [1,2,3]

// Empty set stream
(Set new stream) asList
// => []

// Single element set stream
((Set new add: 42) stream) asList
// => [42]

// Select on set stream
(((((Set new add: 1) add: 2) add: 3) stream) select: [:n | n > 1]) asList
// => [2,3]

// Collect on set stream
(((((Set new add: 1) add: 2) add: 3) stream) collect: [:n | n * 10]) asList
// => [10,20,30]

// Set stream returns Stream
((Set new add: 1) stream) class
// => Stream

// reject on set stream
(((((Set new add: 1) add: 2) add: 3) stream) reject: [:n | n =:= 2]) asList
// => [1,3]

// drop on set stream
(((((Set new add: 1) add: 2) add: 3) stream) drop: 1) asList
// => [2,3]

// take on set stream
(((((Set new add: 1) add: 2) add: 3) stream) take: 2)
// => [1,2]

// do: on set stream (returns nil)
((Set new add: 1) stream) do: [:n | n]
// => nil

// inject:into: on set stream
(((((Set new add: 1) add: 2) add: 3) stream) inject: 0 into: [:sum :n | sum + n])
// => 6

// detect on set stream
(((((Set new add: 1) add: 2) add: 3) stream) detect: [:n | n > 1])
// => 2

// anySatisfy on set stream
(((Set new add: 1) add: 2) stream) anySatisfy: [:n | n > 1]
// => true

// allSatisfy on set stream
(((Set new add: 1) add: 2) stream) allSatisfy: [:n | n > 0]
// => true

// === Dictionary stream ===

// Dictionary stream produces Associations
d := #{#a => 1}
// => _

(d stream) asList
// => _

// Single-entry dictionary stream — verify Association
a := ((#{#x => 42} stream) asList) first
// => _

a class
// => Association

a key
// => x

a value
// => 42

// Empty dictionary stream
(#{} stream) asList
// => []

// Dictionary stream returns Stream
(#{#a => 1} stream) class
// => Stream

// Select on dictionary stream
((#{#a => 1, #b => 2, #c => 3} stream) select: [:assoc | assoc value > 1]) asList
// => _

// Collect on dictionary stream — transform associations
((#{#a => 1, #b => 2} stream) collect: [:assoc | assoc value]) asList
// => _

// Detect on dictionary stream
((#{#a => 1, #b => 2, #c => 3} stream) detect: [:assoc | assoc value > 2]) value
// => 3

// reject on dictionary stream
((#{#a => 1, #b => 2, #c => 3} stream) reject: [:assoc | assoc value =:= 2]) asList
// => _

// drop on dictionary stream
((#{#a => 1, #b => 2} stream) drop: 1) asList
// => _

// take on dictionary stream
((#{#a => 1, #b => 2, #c => 3} stream) take: 1)
// => _

// do: on dictionary stream (returns nil)
(#{#a => 1} stream) do: [:assoc | assoc]
// => nil

// inject:into: on dictionary stream — sum values
(#{#a => 1, #b => 2, #c => 3} stream) inject: 0 into: [:sum :assoc | sum + (assoc value)]
// => 6

// anySatisfy on dictionary stream
(#{#a => 1, #b => 2} stream) anySatisfy: [:assoc | assoc value > 1]
// => true

// allSatisfy on dictionary stream
(#{#a => 1, #b => 2} stream) allSatisfy: [:assoc | assoc value > 0]
// => true

// === Stream on: constructor extended ===

// Stream on: with string
(Stream on: 'abc') asList
// => ["a","b","c"]

// Stream on: with set
(Stream on: ((Set new add: 1) add: 2)) asList
// => [1,2]

// Stream on: with dictionary
((Stream on: #{#x => 99}) asList) first value
// => 99
