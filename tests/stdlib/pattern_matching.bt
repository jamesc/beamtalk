// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

// Stdlib tests for pattern matching (BT-406)
//
// Tests the match: keyword message syntax:
//   expr match: [pattern -> body; ...]
//
// NOTE: Stdlib test harness is line-based; use inline (semicolon-separated)
// match arms. Multiline match syntax is tested in E2E tests.
//
// NOTE: Tuple expression literals {a, b} are not yet supported as standalone
// expressions, so tuple pattern matching cannot be tested here. Tuple patterns
// are verified via parser unit tests (parse_match_with_tuple_pattern).

// ═══════════════════════════════════════════════════════════════════════════
// Basic Wildcard Match
// ═══════════════════════════════════════════════════════════════════════════

// Wildcard matches anything
42 match: [_ -> 'matched']
// => matched

// ═══════════════════════════════════════════════════════════════════════════
// Literal Pattern Matching
// ═══════════════════════════════════════════════════════════════════════════

// Match integer literal — first arm
1 match: [1 -> 'one'; 2 -> 'two'; _ -> 'other']
// => one

// Match integer literal — second arm
2 match: [1 -> 'one'; 2 -> 'two'; _ -> 'other']
// => two

// Match integer literal — fallthrough to wildcard
3 match: [1 -> 'one'; 2 -> 'two'; _ -> 'other']
// => other

// Match symbol literal
#ok match: [#ok -> 'success'; #error -> 'failure'; _ -> 'unknown']
// => success

#error match: [#ok -> 'success'; #error -> 'failure'; _ -> 'unknown']
// => failure

// Match string literal
'hello' match: ['hello' -> 'greeting'; _ -> 'other']
// => greeting

// ═══════════════════════════════════════════════════════════════════════════
// Variable Pattern Matching
// ═══════════════════════════════════════════════════════════════════════════

// Variable captures the matched value
42 match: [x -> x + 1]
// => 43

// ═══════════════════════════════════════════════════════════════════════════
// Guard Expressions
// ═══════════════════════════════════════════════════════════════════════════

// Match with guard — positive
10 match: [x when: [x > 0] -> 'positive'; _ -> 'non-positive']
// => positive

// Match with guard — non-positive
-5 match: [x when: [x > 0] -> 'positive'; _ -> 'non-positive']
// => non-positive

// Guard with arithmetic comparison
42 match: [x when: [x > 100] -> 'big'; x when: [x > 10] -> 'medium'; _ -> 'small']
// => medium

// ═══════════════════════════════════════════════════════════════════════════
// Match on Computed Value
// ═══════════════════════════════════════════════════════════════════════════

// Match on expression result
(3 + 4) match: [7 -> 'correct'; _ -> 'wrong']
// => correct

// ═══════════════════════════════════════════════════════════════════════════
// Negative Number Patterns
// ═══════════════════════════════════════════════════════════════════════════

// Match negative integer
-1 match: [-1 -> 'minus one'; 0 -> 'zero'; _ -> 'other']
// => minus one

0 match: [-1 -> 'minus one'; 0 -> 'zero'; _ -> 'other']
// => zero
