// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

// BT-483: Mutation-threaded control flow returns {Result, State} tuples
// Verifies that methods with mutation-threaded control flow as the last
// expression return meaningful values instead of nil.

// @load tests/e2e/fixtures/mutation_return_values.bt

actor := MutationReturnValues spawn
// => _

// === inject:into: returns accumulator result ===

(actor setValue: 0) await
// => _

// inject:into: as last expression should return accumulator (6), not nil
// Note: [:sum :item | ...] maps sum=ListElement, item=Accumulator (foldl convention)
// With #(1,2,3) and init 0: AccOut after 3 steps = 6
(actor sumViaInject: #(1, 2, 3)) await
// => 6

// State should also be updated (side effect of mutations)
// self.value += item (accumulator): 0 + 0 + 1 + 3 = 4
actor getValue await
// => 4

// === on:do: returns try body result on success ===

(actor setValue: 0) await
// => _

// safeAdd: succeeds, should return self.value after mutation (10)
(actor safeAdd: 10) await
// => 10

actor getValue await
// => 10

// === on:do: returns handler result on exception ===

(actor setValue: 0) await
// => _

// failingAdd triggers exception, handler returns -999
(actor failingAdd) await
// => -999

// Handler's mutation should be applied (0 + 100 = 100)
actor getValue await
// => 100

// === ensure: returns try body result ===

(actor setValue: 0) await
// => _

// addWithCleanup: 5 — body returns self.value (5), cleanup adds 1000
(actor addWithCleanup: 5) await
// => 5

// State: body set value to 5, cleanup added 1000 → 1005
actor getValue await
// => 1005
