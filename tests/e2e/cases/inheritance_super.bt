// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

// ===========================================================================
// SUPER SENDS - Inheritance and Method Dispatch
// ===========================================================================
//
// Tests the 'super' keyword for calling parent class implementations.
// This is a critical feature for object-oriented programming.
//
// Related: BT-95 (beamtalk_class:super_dispatch/3)

// TEMPORARILY DISABLED: BT-189 regression blocks @load for actor classes
// Semantic analyzer rejects valid `self` in method bodies.
// Re-enable when BT-189 is fixed.
//
// For now, see runtime/test/beamtalk_codegen_simulation_tests.erl for verification:
//   - super_calls_parent_method_test
//   - super_multiple_calls_test
//   - super_with_different_method_test
//   - super_maintains_state_test
//   - super_with_init_args_test
// All 6 tests pass with generated code using beamtalk_class:super_dispatch/3

// When BT-189 is fixed, uncomment these directives:
// load tests/e2e/fixtures/counter.bt
// load tests/e2e/fixtures/logging_counter.bt

// ===========================================================================
// BASIC SUPER SEND
// ===========================================================================

// Test: Super calls parent implementation
// LoggingCounter.increment logs, then calls Counter.increment
// c := Counter spawn
// c increment
// // => 1

// c increment
// // => 2

// lc := LoggingCounter spawn
// lc increment
// // => 1

// // Verify log was incremented
// lc getLogCount
// // => 1

// ===========================================================================
// MULTIPLE SUPER CALLS
// ===========================================================================

// Test: Multiple super calls accumulate properly
// lc2 := LoggingCounter spawn
// lc2 increment
// // => 1

// lc2 increment
// // => 2

// lc2 increment
// // => 3

// // Verify all calls were logged
// lc2 getLogCount
// // => 3

// ===========================================================================
// SUPER WITH DIFFERENT METHOD
// ===========================================================================

// Test: Super works for methods that don't modify state
// lc3 := LoggingCounter spawn
// lc3 increment
// // => 1

// // getValue just calls super, no logging
// lc3 getValue
// // => 1

// // Log count unchanged (getValue doesn't log)
// lc3 getLogCount
// // => 1

// ===========================================================================
// SUPER MAINTAINS SEPARATE INSTANCE STATE
// ===========================================================================

// Test: Each instance maintains its own state
// parent := Counter spawn
// child := LoggingCounter spawn

// parent increment
// // => 1

// child increment
// // => 1

// parent increment
// // => 2

// child increment
// // => 2

// // Parent has no logCount
// parent getValue
// // => 2

// // Child has logCount
// child getLogCount
// // => 2

// child getValue
// // => 2

// ===========================================================================
// IMPLEMENTATION NOTES
// ===========================================================================
//
// Super dispatch flow:
// 1. Compiler generates: call 'beamtalk_class':'super_dispatch'(State, Selector, Args)
// 2. Runtime looks up current class from State.__class__
// 3. Queries class process for superclass
// 4. Walks inheritance chain until method found
// 5. Invokes method with current instance state
//
// Critical: Uses beamtalk_class:super_dispatch/3 (not beamtalk_classes)
// This was fixed in BT-95 code review (commit 8e3b912).
//
// Without this fix, all super sends would fail at runtime with:
//   ** exception error: undefined function beamtalk_classes:super_dispatch/3

