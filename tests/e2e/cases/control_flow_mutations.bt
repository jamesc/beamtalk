// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

// E2E tests for control flow with mutations
//
// These tests verify that variables mutated inside control flow blocks
// (whileTrue:, whileFalse:, timesRepeat:, to:do:) correctly update REPL bindings.
//
// This functionality is provided by BT-145: Update REPL bindings after control flow mutations

// ===========================================================================
// TIMES REPEAT WITH MUTATIONS
// ===========================================================================

// Simple counter - mutated inside timesRepeat:
count := 0
// => 0

3 timesRepeat: [count := count + 1]
// => nil

count
// => 3

// Reset and test different increment
count := 0
// => 0

5 timesRepeat: [count := count + 2]
// => nil

count
// => 10

// ===========================================================================
// WHILE TRUE WITH MUTATIONS
// ===========================================================================

// Single variable mutation
a := 1
// => 1

[a < 5] whileTrue: [a := a + 1]
// => nil

a
// => 5

// Multiple variable mutations
x := 1
// => 1

y := 2
// => 2

[x < 5] whileTrue: [x := x + 1. y := y * 2]
// => nil

x
// => 5

y
// => 32

// ===========================================================================
// WHILE FALSE WITH MUTATIONS
// ===========================================================================

// Countdown with whileFalse:
countdown := 5
// => 5

[countdown == 0] whileFalse: [countdown := countdown - 1]
// => nil

countdown
// => 0

// ===========================================================================
// TO:DO: WITH MUTATIONS
// ===========================================================================

// Sum of range 1..10
total := 0
// => 0

1 to: 10 do: [:n | total := total + n]
// => nil

total
// => 55

// Product accumulation
product := 1
// => 1

1 to: 5 do: [:n | product := product * n]
// => nil

product
// => 120

// ===========================================================================
// COMPLEX EXPRESSIONS
// ===========================================================================

// Multiple sequential mutations
alpha := 10
// => 10

beta := 20
// => 20

3 timesRepeat: [alpha := alpha + 5]
// => nil

[beta < 50] whileTrue: [beta := beta + 10]
// => nil

alpha
// => 25

beta
// => 50

// ===========================================================================
// VERIFICATION OF INDEPENDENT SCOPES
// ===========================================================================

// Each control flow should work independently
independent1 := 0
// => 0

independent2 := 100
// => 100

2 timesRepeat: [independent1 := independent1 + 7]
// => nil

[independent2 > 80] whileTrue: [independent2 := independent2 - 5]
// => nil

independent1
// => 14

independent2
// => 80

// ===========================================================================
// TO:BY:DO: WITH MUTATIONS (BT-35)
// ===========================================================================

// Positive step - iterate through odd numbers
oddSum := 0
// => 0

1 to: 10 by: 2 do: [:n | oddSum := oddSum + n]
// => nil

oddSum
// => 25

// Negative step - countdown
countdown := 0
// => 0

10 to: 1 by: -1 do: [:n | countdown := countdown + 1]
// => nil

countdown
// => 10

// Custom step with accumulation
total := 0
// => 0

0 to: 100 by: 10 do: [:n | total := total + n]
// => nil

total
// => 550

// Verify step affects loop correctly - step by 3
everyThird := 0
// => 0

0 to: 15 by: 3 do: [:i | everyThird := everyThird + 1]
// => nil

everyThird
// => 6

// Edge case: Start > End with positive step - should not execute
noExec1 := 0
// => 0

10 to: 1 by: 1 do: [:n | noExec1 := noExec1 + 1]
// => nil

noExec1
// => 0

// Edge case: Start < End with negative step - should not execute
noExec2 := 0
// => 0

1 to: 10 by: -1 do: [:n | noExec2 := noExec2 + 1]
// => nil

noExec2
// => 0

// Edge case: Start = End - should execute exactly once
exactlyOnce := 0
// => 0

5 to: 5 by: 1 do: [:n | exactlyOnce := exactlyOnce + 1]
// => nil

exactlyOnce
// => 1


// Edge case: Step of 0 - should not execute (prevents infinite loop)
stepZero := 0
// => 0

1 to: 10 by: 0 do: [:n | stepZero := stepZero + 1]
// => nil

stepZero
// => 0
