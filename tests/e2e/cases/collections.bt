// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

// E2E tests for collection/List methods (BT-44)

// ===========================================================================
// TIER 1: ESSENTIAL METHODS
// ===========================================================================

// --- last ---
#(1, 2, 3) last
// => 3

#(42) last
// => 42

// --- at: ---
#(10, 20, 30) at: 1
// => 10

#(10, 20, 30) at: 3
// => 30

// --- includes: ---
#(1, 2, 3) includes: 2
// => true

#(1, 2, 3) includes: 5
// => false

#() includes: 1
// => false

// --- sort ---
#(3, 1, 2) sort
// => [1,2,3]

#() sort
// => []

// --- reversed ---
#(1, 2, 3) reversed
// => [3,2,1]

#() reversed
// => []

// --- detect: ---
#(1, 2, 3, 4) detect: [:x | x > 2]
// => 3

// --- detect:ifNone: ---
#(1, 2, 3) detect: [:x | x > 10] ifNone: [0]
// => 0

#(1, 2, 3) detect: [:x | x > 1] ifNone: [0]
// => 2

// ===========================================================================
// TIER 2: FUNCTIONAL METHODS
// ===========================================================================

// --- take: ---
#(1, 2, 3, 4, 5) take: 3
// => [1,2,3]

#(1, 2) take: 5
// => [1,2]

// --- drop: ---
#(1, 2, 3, 4, 5) drop: 2
// => [3,4,5]

#(1, 2) drop: 5
// => []

// --- flatten ---
#(#(1, 2), #(3, 4)) flatten
// => [1,2,3,4]

// --- flatMap: ---
#(1, 2, 3) flatMap: [:x | #(x, (x * 10))]
// => [1,10,2,20,3,30]

// --- count: ---
#(1, 2, 3, 4, 5) count: [:x | x > 2]
// => 3

// --- anySatisfy: ---
#(1, 2, 3) anySatisfy: [:x | x > 2]
// => true

#(1, 2, 3) anySatisfy: [:x | x > 5]
// => false

// --- allSatisfy: ---
#(1, 2, 3) allSatisfy: [:x | x > 0]
// => true

#(1, 2, 3) allSatisfy: [:x | x > 1]
// => false

// ===========================================================================
// TIER 3: ADVANCED METHODS
// ===========================================================================

// --- unique ---
#(3, 1, 2, 1, 3) unique
// => [1,2,3]

// --- takeWhile: ---
#(1, 2, 3, 4, 5) takeWhile: [:x | x < 4]
// => [1,2,3]

// --- dropWhile: ---
#(1, 2, 3, 4, 5) dropWhile: [:x | x < 3]
// => [3,4,5]

// --- intersperse: ---
#(1, 2, 3) intersperse: 0
// => [1,0,2,0,3]

#() intersperse: 0
// => []

// --- add: ---
#(1, 2, 3) add: 4
// => [1,2,3,4]

#() add: 1
// => [1]

// ===========================================================================
// ITERATION (existing methods, now tested in E2E)
// ===========================================================================

// --- collect: ---
#(1, 2, 3) collect: [:x | x * 2]
// => [2,4,6]

// --- select: ---
#(1, 2, 3, 4) select: [:x | (x % 2) = 0]
// => [2,4]

// --- reject: ---
#(1, 2, 3, 4) reject: [:x | x isEven]
// => [1,3]

// --- inject:into: ---
#(1, 2, 3, 4) inject: 0 into: [:sum :x | sum + x]
// => 10

// ===========================================================================
// ADVANCED METHODS (BT-419: verify codegen→runtime plumbing)
// ===========================================================================

// --- zip: ---
#(1, 2, 3) zip: #(4, 5, 6)
// => _

// --- groupBy: ---
#(1, 2, 3, 4, 5, 6) groupBy: [:x | x isEven]
// => _

// --- partition: ---
#(1, 2, 3, 4) partition: [:x | x > 2]
// => _

// --- sort: (with comparator) ---
#(3, 1, 2) sort: [:a :b | a >= b]
// => [3,2,1]

// ===========================================================================
// BT-75: NEW METHODS (++, from:to:, indexOf:, eachWithIndex:)
// ===========================================================================

// --- ++ (concatenation) ---
#(1, 2) ++ #(3, 4)
// => [1,2,3,4]

#() ++ #(1, 2)
// => [1,2]

#(1, 2) ++ #()
// => [1,2]

#() ++ #()
// => []

// --- from:to: (subsequence, 1-based inclusive) ---
#(1, 2, 3, 4, 5) from: 2 to: 4
// => [2,3,4]

// Wildcard for single-element result (Erlang printable_list ambiguity with small integers)
#(1, 2, 3, 4, 5) from: 1 to: 1
// => _

// Two-element subsequence verifies inclusive bounds
#(1, 2, 3, 4, 5) from: 1 to: 2
// => [1,2]

#(1, 2, 3, 4, 5) from: 1 to: 5
// => [1,2,3,4,5]

#(1, 2, 3) from: 3 to: 2
// => []

// from:to: beyond list end returns available elements
#(1, 2, 3) from: 2 to: 10
// => [2,3]

// --- indexOf: (1-based, nil if not found) ---
#(10, 20, 30) indexOf: 20
// => 2

#(10, 20, 30) indexOf: 10
// => 1

#(10, 20, 30) indexOf: 30
// => 3

#(10, 20, 30) indexOf: 99
// => nil

// indexOf: returns first match when duplicates exist
#(1, 2, 3, 2) indexOf: 2
// => 2

#() indexOf: 1
// => nil

// --- eachWithIndex: (1-based index) ---
// eachWithIndex: returns nil after iterating
#(10, 20, 30) eachWithIndex: [:elem :idx | elem + idx]
// => nil

// Verify eachWithIndex: iterates (empty list is a no-op)
#() eachWithIndex: [:elem :idx | elem]
// => nil

// Verify eachWithIndex: passes correct 1-based indices indirectly:
// eachWithIndex: uses same 1-based indexing as indexOf: (verified above).
// Direct index assertion not possible in E2E since blocks can't accumulate results.
// The block receives (elem, idx) — verify it doesn't error with 2-arg block:
#(100, 200, 300) eachWithIndex: [:elem :idx | elem + idx]
// => nil

// --- ++ with variables ---
a := #(1, 2, 3)
// => _

a ++ #(4, 5)
// => [1,2,3,4,5]
