// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

/// Set â€” Unordered collection of unique elements.
///
/// Sets are immutable collections backed by Erlang's ordsets module.
/// Operations that "modify" a set return a new set.
///
/// ## Examples
/// ```beamtalk
/// Set new class                    // => Set
/// (Set new add: 1) includes: 1    // => true
/// (Set new add: 1) size           // => 1
/// ```
sealed Collection subclass: Set
  state: elements = #()

  /// Number of elements in the set.
  ///
  /// ## Examples
  /// ```beamtalk
  /// (Set new add: 1) size           // => 1
  /// Set new size                    // => 0
  /// ```
  size -> Integer => @primitive "size"

  /// Test if the set has no elements.
  ///
  /// ## Examples
  /// ```beamtalk
  /// Set new isEmpty                 // => true
  /// ```
  isEmpty -> Boolean => @primitive "isEmpty"

  /// Test if the set contains the given element.
  ///
  /// ## Examples
  /// ```beamtalk
  /// (Set new add: 1) includes: 1   // => true
  /// (Set new add: 1) includes: 2   // => false
  /// ```
  includes: element -> Boolean => @primitive "includes:"

  /// Return a new set with the element added.
  ///
  /// ## Examples
  /// ```beamtalk
  /// (Set new add: 1) size          // => 1
  /// ```
  add: element -> Set => @primitive "add:"

  /// Return a new set with the element removed.
  ///
  /// ## Examples
  /// ```beamtalk
  /// ((Set new add: 1) remove: 1) isEmpty   // => true
  /// ```
  remove: element -> Set => @primitive "remove:"

  /// Return a new set with elements from both sets.
  ///
  /// ## Examples
  /// ```beamtalk
  /// (Set new add: 1) union: (Set new add: 2)
  /// ```
  union: other: Set -> Set => @primitive "union:"

  /// Return a new set with only elements present in both sets.
  ///
  /// ## Examples
  /// ```beamtalk
  /// ((Set new add: 1) add: 2) intersection: ((Set new add: 2) add: 3)
  /// ```
  intersection: other: Set -> Set => @primitive "intersection:"

  /// Return a new set with elements in the receiver but not in `other`.
  ///
  /// ## Examples
  /// ```beamtalk
  /// ((Set new add: 1) add: 2) difference: (Set new add: 2)
  /// ```
  difference: other: Set -> Set => @primitive "difference:"

  /// Test if all elements of the receiver are in `other`.
  ///
  /// ## Examples
  /// ```beamtalk
  /// (Set new add: 1) isSubsetOf: ((Set new add: 1) add: 2)   // => true
  /// ```
  isSubsetOf: other: Set -> Boolean => @primitive "isSubsetOf:"

  /// Convert the set to a list of elements.
  ///
  /// ## Examples
  /// ```beamtalk
  /// (Set new add: 1) asList        // => #(1)
  /// ```
  asList -> List => @primitive "asList"

  /// Create a set from a list of elements.
  ///
  /// ## Examples
  /// ```beamtalk
  /// Set new fromList: #(1, 2, 2, 3)
  /// ```
  fromList: list: List -> Set => @primitive "fromList:"

  /// Iterate over each element, evaluating `block` with each one.
  ///
  /// ## Examples
  /// ```beamtalk
  /// (Set new add: 1) do: [:x | Transcript show: x]
  /// ```
  do: block: Block => @primitive "do:"

  /// Return a developer-readable string representation.
  ///
  /// ## Examples
  /// ```beamtalk
  /// Set new printString
  /// ```
  printString -> String => @primitive "printString"

  /// Return a lazy Stream over the set elements.
  ///
  /// ## Examples
  /// ```beamtalk
  /// ((Set new add: 1) stream) asList   // => #(1)
  /// ```
  stream -> Stream => @primitive "stream"

  /// Human-readable description of the receiver.
  ///
  /// ## Examples
  /// ```beamtalk
  /// Set new describe               // => "a Set"
  /// ```
  describe -> String => "a Set"
