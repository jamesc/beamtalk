// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

// Set - Unordered collection of unique elements
//
// Uses Erlang's ordsets module. Automatic deduplication.

Object subclass: Set
  // Construction
  new => @primitive 'new'
  fromList: aList => @primitive 'fromList:'
  fromArray: anArray => Set fromList: anArray asList
  with: element => (Set new) add: element
  with: e1 with: e2 => ((Set new) add: e1) add: e2
  with: e1 with: e2 with: e3 => (((Set new) add: e1) add: e2) add: e3

  // Size
  size => @primitive 'size'
  isEmpty => self size = 0
  isNotEmpty => self size > 0

  // Membership
  includes: element => @primitive 'includes:'
  excludes: element => (self includes: element) not

  // Adding and removing
  add: element => @primitive 'add:'
  addAll: collection =>
    collection inject: self into: [:set :elem | set add: elem]

  remove: element => @primitive 'remove:'
  removeAll: collection =>
    collection inject: self into: [:set :elem | set remove: elem]

  // Set operations
  union: other => @primitive 'union:'
  intersection: other => @primitive 'intersection:'
  difference: other => @primitive 'difference:'
  symmetricDifference: other =>
    (self union: other) difference: (self intersection: other)

  // Set predicates
  isSubsetOf: other => @primitive 'isSubsetOf:'
  isSupersetOf: other => other isSubsetOf: self
  isProperSubsetOf: other =>
    (self isSubsetOf: other) and: [self size < other size]

  isDisjointFrom: other =>
    (self intersection: other) isEmpty

  // Iteration
  each: block => @primitive 'each:'

  collect: block =>
    self inject: Set new into: [:result :elem |
      result add: (block value: elem)
    ]

  select: block =>
    self inject: Set new into: [:result :elem |
      (block value: elem) ifTrue: [result add: elem] ifFalse: [result]
    ]

  reject: block =>
    self select: [:elem | (block value: elem) not]

  inject: initial into: block => @primitive 'inject:into:'

  // Finding elements
  detect: block =>
    self each: [:elem |
      (block value: elem) ifTrue: [^elem]
    ].
    nil

  detect: block ifNone: defaultBlock =>
    result := self detect: block.
    result = nil ifTrue: [defaultBlock value] ifFalse: [result]

  anyOne =>
    self isEmpty ifTrue: [self error: 'Set is empty'].
    self detect: [:e | true]

  // Conversion
  asList => @primitive 'asList'
  asArray => self asList asArray
  asSet => self

  // Comparison â€” pure Beamtalk
  = other =>
    other isSet ifFalse: [^false].
    self size = other size ifFalse: [^false].
    self isSubsetOf: other

  // Type tests
  isArray => false
  isList => false
  isSet => true
  isDictionary => false

  // Power set
  powerSet =>
    self isEmpty ifTrue: [^Set with: Set new].
    elem := self anyOne.
    rest := self remove: elem.
    restPower := rest powerSet.
    withElem := restPower collect: [:subset | subset add: elem].
    restPower union: withElem
