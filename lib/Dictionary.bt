// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

/// Dictionary — Immutable key-value collection.
///
/// Dictionaries are backed by Erlang maps. Operations that "modify"
/// a dictionary return a new dictionary — the original is unchanged.
///
/// ## BEAM Mapping
/// Beamtalk dictionaries map directly to Erlang maps.
///
/// ## Examples
/// ```beamtalk
/// #{#name => "Alice"} class                   // => Dictionary
/// #{#name => "Alice"} at: #name               // => "Alice"
/// #{#a => 1} at: #b put: 2                    // => #{#a => 1, #b => 2}
/// ```
sealed Collection subclass: Dictionary

  /// Number of key-value pairs.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #{#a => 1, #b => 2} size                   // => 2
  /// ```
  size => @primitive "size"

  /// Return a list of all keys.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #{#a => 1, #b => 2} keys
  /// ```
  keys => @primitive "keys"

  /// Return a list of all values.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #{#a => 1, #b => 2} values
  /// ```
  values => @primitive "values"

  /// Return the value associated with `key`. Raises an error if not found.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #{#name => "Alice"} at: #name              // => "Alice"
  /// ```
  at: key => @primitive "at:"

  /// Return the value for `key`, or evaluate `block` if absent.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #{#a => 1} at: #b ifAbsent: [0]            // => 0
  /// ```
  at: key ifAbsent: block => @primitive "at:ifAbsent:"

  /// Return a new dictionary with `key` mapped to `value`.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #{#a => 1} at: #b put: 2                   // => #{#a => 1, #b => 2}
  /// ```
  at: key put: value => @primitive "at:put:"

  /// Test if the dictionary contains the given key.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #{#a => 1} includesKey: #a                 // => true
  /// #{#a => 1} includesKey: #b                 // => false
  /// ```
  includesKey: key => @primitive "includesKey:"

  /// Return a new dictionary without the given key.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #{#a => 1, #b => 2} removeKey: #a          // => #{#b => 2}
  /// ```
  removeKey: key => @primitive "removeKey:"

  /// Merge another dictionary into the receiver (other's values win on conflict).
  ///
  /// ## Examples
  /// ```beamtalk
  /// #{#a => 1} merge: #{#b => 2}               // => #{#a => 1, #b => 2}
  /// ```
  merge: other => @primitive "merge:"

  /// Test if the dictionary contains the given value.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #{#a => 1, #b => 2} includes: 1     // => true
  /// #{#a => 1} includes: 3              // => false
  /// ```
  includes: value => @primitive "includes:"

  /// Iterate over each value, evaluating `block` with each one.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #{#a => 1, #b => 2} do: [:v | Transcript show: v]
  /// ```
  do: block => @primitive "do:"

  /// Iterate over each key-value pair, evaluating `block` with key and value.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #{#a => 1} keysAndValuesDo: [:k :v | Transcript show: k]
  /// ```
  keysAndValuesDo: block => @primitive "keysAndValuesDo:"

  /// Return a string representation using Beamtalk syntax.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #{#a => 1} printString                     // => "#{#a => 1}"
  /// ```
  printString => @primitive "printString"

  /// Return a lazy Stream over the dictionary entries as Associations.
  ///
  /// ## Examples
  /// ```beamtalk
  /// (#{#a => 1} stream) asList
  /// ```
  stream => @primitive "stream"

  /// Human-readable description of the receiver.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #{#a => 1} describe                        // => "a Dictionary"
  /// ```
  describe => "a Dictionary"
