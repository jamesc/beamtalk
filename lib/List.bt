// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

// List - Linked list collection (Erlang list)
//
// Singly-linked sequences with O(1) prepend, O(n) random access.

Object subclass: List
  // Binary operators first (parser constraint)
  ++ other => @primitive '++'

  // Construction
  new => @primitive 'new'

  // Create list with n copies of element
  new: size withAll: element =>
    result := [].
    size timesRepeat: [result := result prepend: element].
    result

  fromArray: anArray => anArray asList

  // Head/tail access
  head => @primitive 'head'
  tail => @primitive 'tail'
  first => self head
  rest => self tail

  headIfEmpty: defaultBlock =>
    self isEmpty ifTrue: [defaultBlock value] ifFalse: [self head]

  tailIfEmpty: defaultBlock =>
    self isEmpty ifTrue: [defaultBlock value] ifFalse: [self tail]

  // Cons operations
  prepend: element => @primitive 'prepend:'
  cons: element => self prepend: element

  // Index access
  at: index => @primitive 'at:'
  at: index put: value => @primitive 'at:put:'
  size => @primitive 'size'
  last => @primitive 'last'

  // Append
  append: element => self ++ [element]

  // Reordering
  reversed => @primitive 'reversed'
  sorted => @primitive 'sorted'
  sortedBy: block => @primitive 'sortedBy:'

  // Removal
  remove: element => @primitive 'remove:'
  removeAll: element =>
    self select: [:e | e ~= element]

  removeAt: index =>
    (self collectWithIndex: [:i :e |
      i = index ifTrue: [nil] ifFalse: [e]
    ]) select: [:e | e ~= nil]

  // Conversion
  asList => self
  asArray => @primitive 'asArray'
  asSet => @primitive 'asSet'

  // Comparison â€” pure Beamtalk
  = other =>
    other isList ifFalse: [^false].
    self size = other size ifFalse: [^false].
    self with: other do: [:a :b |
      a = b ifFalse: [^false]
    ].
    true

  // Type tests
  isArray => false
  isList => true
  isSet => false
  isDictionary => false

  // Iteration
  each: block => @primitive 'each:'
  collect: block => @primitive 'collect:'
  select: block => @primitive 'select:'
  reject: block => @primitive 'reject:'
  inject: initial into: block => @primitive 'inject:into:'

  // List-specific operations
  flatten => @primitive 'flatten'
  flattenDeep => @primitive 'flattenDeep'

  zip: other =>
    self with: other collect: [:a :b | {a, b}]

  unzip =>
    firsts := self collect: [:pair | pair at: 1].
    seconds := self collect: [:pair | pair at: 2].
    {firsts, seconds}

  takeWhile: block => @primitive 'takeWhile:'
  dropWhile: block => @primitive 'dropWhile:'

  splitWith: block =>
    before := self takeWhile: [:e | (block value: e) not].
    after := self dropWhile: [:e | (block value: e) not].
    {before, after}

  partition: block =>
    matching := self select: block.
    notMatching := self reject: block.
    {matching, notMatching}

  intersperse: separator =>
    self isEmpty ifTrue: [^[]].
    self size = 1 ifTrue: [^[self head]].
    result := [self head].
    self tail each: [:e |
      result := result ++ [separator, e]
    ].
    result
