// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

// ═══════════════════════════════════════════════════════════════════════════
// NOTE: This file is API DOCUMENTATION for the Beamtalk standard library.
//
// Messages marked "// implemented by compiler" are built-in primitives with
// optimized implementations in the compiler. This file defines their API
// contracts and expected behavior for users.
// ═══════════════════════════════════════════════════════════════════════════

// Object - Common root class for most Beamtalk classes
//
// Object inherits from ProtoObject and adds the standard protocol that almost
// all objects need: reflection, nil testing, debugging, and comparison. Most
// user classes should inherit from Actor (which inherits from Object) rather
// than from Object directly.
//
// ## Class Hierarchy
//
// ```
// ProtoObject (minimal root, identity and fallback)
//   └─ Object (reflection, nil testing, debugging)
//        └─ Actor (async-first process-based objects)
//             └─ (user classes: Counter, Worker, etc.)
// ```
//
// ## When to Inherit from Object
//
// Use Object directly for:
// - **Non-concurrent utility classes** (rare in Beamtalk)
// - **Value objects** that don't need process isolation
// - **Data structures** used across processes
//
// Most application code should inherit from Actor instead, which adds
// spawning, supervision, and async messaging on top of Object.
//
// ## Core Protocols
//
// ### Reflection
// - `class` - Returns the object's class (inherited from ProtoObject)
// - `respondsTo:` - Check if object understands a message
// - `instVarNames` - List of instance variable names
// - `instVarAt:` - Read instance variable by name
// - `instVarAt:put:` - Write instance variable by name
//
// ### Nil Testing  
// - `isNil` - Returns false for all objects except Nil
// - `notNil` - Returns true for all objects except Nil
// - `ifNil:` - Conditional execution if nil
// - `ifNotNil:` - Conditional execution if not nil
// - `ifNil:ifNotNil:` - Two-way conditional
//
// ### Debugging
// - `inspect` - Print textual representation
// - `describe` - Return string description
//
// ### Comparison (TODO - not yet implemented)
// - `=` - Value equality (subclasses override)
// - `hash` - Hash code for collections
// - `<`, `>`, `<=`, `>=` - Ordering (Magnitude protocol)
//
// ## BEAM Mapping
//
// Object methods compile to functions in the instance module. For example,
// a Counter class generates `beamtalk_counter.erl` with all instance methods.
//
// The Object protocol is available to all classes that inherit from Object
// (which is everything except classes directly inheriting from ProtoObject).

ProtoObject subclass: Object
  // ## Nil Testing Protocol
  //
  // These messages allow nil-safe control flow. All objects (except Nil) return
  // false for `isNil` and true for `notNil`.
  //
  // Examples:
  // ```beamtalk
  // 42 isNil        // => false
  // 42 notNil       // => true
  // 42 ifNil: [0]   // => 42
  // 42 ifNotNil: [:v | v + 1]  // => 43
  // ```

  // Returns false for all objects except Nil
  isNil => false

  // Returns true for all objects except Nil
  notNil => true

  // Returns self without evaluating the block (non-nil objects)
  ifNil: nilBlock => self

  // Evaluates the block passing the receiver as argument (non-nil objects)
  ifNotNil: notNilBlock => notNilBlock value: self

  // Evaluates notNilBlock with receiver (non-nil objects)
  ifNil: nilBlock ifNotNil: notNilBlock => notNilBlock value: self

  // Evaluates notNilBlock with receiver (non-nil objects, reversed order)
  ifNotNil: notNilBlock ifNil: nilBlock => notNilBlock value: self

  // ## Debugging Protocol
  //
  // These messages help with inspecting and debugging objects.

  // Show this object's description on the Transcript
  inspect => Transcript show: self describe

  // Returns a textual description of this object
  // Subclasses should override to provide detailed info
  describe => 'an Object'

  // ## Reflection Protocol
  //
  // These messages enable runtime introspection of object structure.
  // Currently implemented for actors; primitive support planned (see BT-163, BT-164).
  //
  // Examples:
  // ```beamtalk
  // counter respondsTo: #increment
  // // => true
  //
  // counter instVarNames
  // // => [#value]
  //
  // counter instVarAt: #value
  // // => 0
  // ```
  
  // Check if this object responds to a given selector
  // 
  // For actors: Queries the method table in the object's state
  // For primitives: Planned to check the primitive's method table (not yet implemented - see BT-163)
  //
  // Arguments:
  // - selector: Symbol representing the message name (e.g., #increment)
  //
  // Returns: true if object understands the message, false otherwise
  respondsTo: selector => // implemented by compiler
  
  // Returns list of instance variable names
  //
  // For actors: Extracts field names from the state map (excluding internals)
  // For primitives: Planned to return empty list (not yet implemented - see BT-164)
  //
  // Returns: Array of symbols representing instance variable names
  instVarNames => // implemented by compiler
  
  // Read an instance variable by name
  //
  // For actors: Reads field from the state map
  // For primitives: Planned to return nil (not yet implemented - see BT-164)
  //
  // Arguments:
  // - name: Symbol representing the instance variable name
  //
  // Returns: Current value of the instance variable, or nil if not found
  instVarAt: name => // implemented by compiler

  // ## Instantiation Protocol (Class Methods)
  //
  // These class messages create new instances of value types.
  // Value types are plain Erlang terms (maps/records) with no process.
  //
  // **IMPORTANT:** These only work for Object subclasses (value types).
  // Actor subclasses must use `spawn` instead.

  // Create a new instance with default field values
  //
  // This is a class method that creates a value type instance.
  // All fields are initialized to their default values (or nil if no default).
  //
  // Example:
  // ```beamtalk
  // Point new          // => Point instance with default x, y
  // ```
  //
  // Returns: New instance of this class
  new => // implemented by compiler

  // Create a new instance with initialization arguments
  //
  // This is a class method that creates a value type instance with custom
  // initial field values. Arguments should be a dictionary mapping field
  // names to values.
  //
  // Example:
  // ```beamtalk
  // Point new: #{x => 3, y => 4}   // => Point with x=3, y=4
  // ```
  //
  // Arguments:
  // - initArgs: Dictionary of field names to initial values
  //
  // Returns: New instance of this class with specified field values
  new: initArgs => // implemented by compiler
