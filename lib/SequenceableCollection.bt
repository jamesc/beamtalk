// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

// SequenceableCollection - Protocol for ordered, indexed collections
//
// Extends Collection with operations requiring ordering and index-based access.
// Concrete subtypes: Array, List.

Object subclass: SequenceableCollection
  // Binary operators first (parser constraint)
  ++ other => @primitive '++'

  // Index-based access (1-based)
  at: index => @primitive 'at:'
  at: index put: value => @primitive 'at:put:'

  // Convenience accessors â€” pure Beamtalk
  first => self at: 1
  last => self at: self size
  second => self at: 2
  third => self at: 3

  // Bounds-checked access
  at: index ifAbsent: defaultBlock =>
    (index >= 1) and: [index <= self size]
      ifTrue: [self at: index]
      ifFalse: [defaultBlock value]

  firstIfAbsent: defaultBlock =>
    self isEmpty ifTrue: [defaultBlock value] ifFalse: [self first]

  lastIfAbsent: defaultBlock =>
    self isEmpty ifTrue: [defaultBlock value] ifFalse: [self last]

  // Subsequence extraction
  from: startIndex to: endIndex => @primitive 'from:to:'
  first: n => self from: 1 to: n
  last: n => self from: (self size - n + 1) to: self size
  allButFirst: n => self from: (n + 1) to: self size
  allButLast: n => self from: 1 to: (self size - n)
  allButFirst => self allButFirst: 1
  allButLast => self allButLast: 1

  // Copying with changes
  copyWith: element => @primitive 'copyWith:'
  copyWithout: element => @primitive 'copyWithout:'
  copyWith: element at: index => @primitive 'copyWith:at:'
  removeAt: index => @primitive 'removeAt:'

  // Reordering
  sorted => @primitive 'sorted'
  sortedBy: block => @primitive 'sortedBy:'
  reversed => @primitive 'reversed'

  // Index finding
  indexOf: element => @primitive 'indexOf:'
  indexOf: element ifAbsent: absentBlock =>
    index := self indexOf: element.
    index = 0 ifTrue: [absentBlock value] ifFalse: [index]

  findFirst: block =>
    1 to: self size do: [:i |
      (block value: (self at: i)) ifTrue: [^i]
    ].
    0

  // Iteration with index
  eachWithIndex: block =>
    1 to: self size do: [:i |
      block value: i value: (self at: i)
    ]

  collectWithIndex: block =>
    self collectWithIndex: block into: self class new

  collectWithIndex: block into: intoCollection =>
    result := intoCollection.
    1 to: self size do: [:i |
      result := result copyWith: (block value: i value: (self at: i))
    ].
    result

  // Pairing operations
  with: otherCollection collect: block => @primitive 'with:collect:'

  with: otherCollection do: block =>
    1 to: (self size min: otherCollection size) do: [:i |
      block value: (self at: i) value: (otherCollection at: i)
    ]

  // Grouping
  pairsDo: block =>
    1 to: self size - 1 by: 2 do: [:i |
      block value: (self at: i) value: (self at: i + 1)
    ]

  overlappingPairsDo: block =>
    1 to: self size - 1 do: [:i |
      block value: (self at: i) value: (self at: i + 1)
    ]

  // Testing order
  isSorted =>
    self size <= 1 ifTrue: [^true].
    1 to: self size - 1 do: [:i |
      (self at: i) > (self at: i + 1) ifTrue: [^false]
    ].
    true

  equals: other =>
    self size = other size ifFalse: [^false].
    1 to: self size do: [:i |
      (self at: i) = (other at: i) ifFalse: [^false]
    ].
    true
