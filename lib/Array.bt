// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

// Array - Fixed-size indexed collection (Erlang tuple)
//
// O(1) element access, O(n) modification (new tuple created).

Object subclass: Array
  // Binary operators first (parser constraint)
  ++ other =>
    other isArray ifFalse: [other := other asArray].
    newSize := self size + other size.
    result := Array new: newSize.
    1 to: self size do: [:i |
      result at: i put: (self at: i)
    ].
    1 to: other size do: [:i |
      result at: self size + i put: (other at: i)
    ].
    result

  // Construction
  new: size => @primitive 'new:'

  new: size withAll: block =>
    1 to: size inject: (self new: size) into: [:arr :i |
      arr at: i put: (block value: i)
    ]

  fromList: aList => aList asArray

  // Size
  size => @primitive 'size'

  // Index access
  at: index => @primitive 'at:'
  at: index put: value => @primitive 'at:put:'

  // Array-specific operations
  append: element =>
    newSize := self size + 1.
    result := Array new: newSize.
    1 to: self size do: [:i |
      result at: i put: (self at: i)
    ].
    result at: newSize put: element.
    result

  prepend: element =>
    newSize := self size + 1.
    result := Array new: newSize.
    result at: 1 put: element.
    1 to: self size do: [:i |
      result at: i + 1 put: (self at: i)
    ].
    result

  // Conversion
  asArray => self
  asList => @primitive 'asList'
  asSet => self asList asSet

  // Comparison â€” pure Beamtalk
  = other =>
    other isArray ifFalse: [^false].
    self size = other size ifFalse: [^false].
    1 to: self size do: [:i |
      (self at: i) = (other at: i) ifFalse: [^false]
    ].
    true

  // Type tests
  isArray => true
  isList => false
  isSet => false
  isDictionary => false

  // Iteration
  each: block => @primitive 'each:'
  collect: block => @primitive 'collect:'
  select: block => @primitive 'select:'
  inject: initial into: block => @primitive 'inject:into:'
