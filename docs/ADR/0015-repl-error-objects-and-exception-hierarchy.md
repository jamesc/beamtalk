# ADR 0015: Signal-Time Exception Objects and Error Class Hierarchy

## Status
Proposed (2026-02-10)

## Context

### The Fundamental Problem

In Smalltalk, exceptions are **always objects**. A `MessageNotUnderstood` is created as an object at signal time ‚Äî the thing being thrown IS the Exception object. In Beamtalk today, `#beamtalk_error{}` is a raw Erlang record that only becomes a Beamtalk Exception object at catch time inside `on:do:` blocks. Everywhere else ‚Äî the REPL, production try/catch, supervision ‚Äî the raw Erlang record leaks through.

This is backwards. The question isn't "should the REPL wrap errors?" ‚Äî it's **"at what point in the pipeline does `#beamtalk_error{}` become an Error object?"**

### Current Error Lifecycle

```
1. Construction:  beamtalk_error:new(does_not_understand, 'Integer')
                  ‚Üí #beamtalk_error{kind, class, selector, message, hint, details}
                  (Erlang record ‚Äî NOT a Beamtalk object)

2a. Dispatch return: {error, #beamtalk_error{...}}
                  (some modules return errors as values, not exceptions)

2b. Raising:      error(#beamtalk_error{...})
                  (raw Erlang record thrown via Erlang exception mechanism;
                   ~54 throw sites in runtime, ~17 generated by codegen)

3. Catch in on:do: codegen:
                  catch <Type, Error, Stack> ->
                    let ExObj = call 'beamtalk_exception_handler':'wrap'(Error) in
                    apply HandlerFun (ExObj)
                  (wrapped into Exception tagged map ONLY at this catch site)

4. Catch in REPL: catch Class:Reason:_Stacktrace ->
                    {error, {eval_error, Class, Reason}, State}
                  (NEVER wrapped ‚Äî format_name/1 falls through to ~p,
                   leaks raw Erlang record syntax)

5. Catch in production try/catch:
                  (raw Erlang record ‚Äî no Beamtalk object at all)
```

### What's Wrong

1. **Inconsistent object model** ‚Äî Inside `on:do:`, errors are proper objects with `message`, `kind`, `selector`, `printString`. Outside, they're raw Erlang records. Same error, different representations depending on where it's caught.

2. **REPL leaks internals** ‚Äî When a runtime error like `42 foo` occurs, the REPL catch wraps it as `{eval_error, error, #beamtalk_error{...}}`. The `format_error_message/1` clause for `{eval_error, Class, Reason}` calls `format_name(Reason)`, which falls through to `io_lib:format("~p", [Reason])` for records, displaying raw Erlang record syntax. Note: a direct `#beamtalk_error{}` clause exists (line 819) but is never reached because the eval error path wraps it in the `{eval_error, ...}` tuple first.

3. **Violates "everything is an object"** ‚Äî Beamtalk's core design principle (from Smalltalk) says everything the user encounters should be an object they can send messages to.

4. **Flat hierarchy** ‚Äî `wrap/1` always creates `#{'$beamtalk_class' => 'Exception'}` regardless of error kind. There's no `RuntimeError`, `TypeError`, or `IOError` ‚Äî all errors look the same to `on:do:` class matching.

5. **No post-error inspection** ‚Äî After an error in the REPL, the error object is gone. Users can't examine what went wrong without wrapping in `on:do:` first.

### What Smalltalk Does

In Pharo Smalltalk, the exception lifecycle is:

```
1. Object created:    MessageNotUnderstood new
                      (Exception object exists BEFORE signaling)

2. Signaled:          exception signal
                      (the OBJECT is what traverses the handler stack)

3. Handler receives:  [:e | e message]
                      (same object ‚Äî no wrapping step)

4. Debugger receives: same object
                      (fully inspectable, resumable)
```

Key insight: **there is no "raw error" that later gets wrapped.** The Exception object IS the error from the very beginning. The `signal` method searches the handler stack with the object itself.

### Current Infrastructure

The wrapping machinery already exists but is only used in `on:do:` catch clauses:

- `lib/Exception.bt` ‚Äî Class with `message`, `hint`, `kind`, `selector`, `errorClass`, `printString`
- `lib/Error.bt` ‚Äî Subclass of Exception
- `beamtalk_exception_handler:wrap/1` ‚Äî Wraps `#beamtalk_error{}` as tagged maps
- `beamtalk_exception_handler:dispatch/3` ‚Äî Message dispatch for Exception objects
- `beamtalk_error.erl` ‚Äî 15+ error kinds, structured construction, formatting

### Constraints

1. **BEAM exception mechanism** ‚Äî Must use Erlang's `error/1`, `throw/1`, `exit/1`. Cannot implement a custom handler stack like Smalltalk's VM-level support.
2. **Erlang interop** ‚Äî Raw Erlang exceptions (`badarith`, `badmatch`, `function_clause`) will always exist and must be handled gracefully.
3. **Performance** ‚Äî Error path is already slow (stack trace capture). Wrapping overhead is negligible.
4. **Value types** ‚Äî Exception objects are tagged maps (value types), not actors.
5. **Backward compatibility** ‚Äî `on:do:` and `ensure:` codegen must continue working.

## Decision

### Core Principle: Errors Are Objects From Birth

**Every `#beamtalk_error{}` is wrapped as an Exception object at the point of raising, not at the point of catching.**

This means the term passed to Erlang's `error/1` is already a Beamtalk object ‚Äî a tagged map with `$beamtalk_class` set to the appropriate error class.

### 1. Signal-Time Wrapping via `beamtalk_error:raise/1`

A new function `beamtalk_error:raise/1` replaces all `error(#beamtalk_error{})` calls:

```erlang
%% beamtalk_error.erl ‚Äî NEW
-spec raise(#beamtalk_error{}) -> no_return().
raise(#beamtalk_error{} = Error) ->
    Wrapped = beamtalk_exception_handler:wrap(Error),
    error(Wrapped).
```

**Before (current):**
```erlang
%% Scattered across runtime ‚Äî ~54 throw sites in .erl files, ~17 generated in codegen
Error0 = beamtalk_error:new(does_not_understand, 'Integer'),
Error1 = beamtalk_error:with_selector(Error0, 'foo'),
error(Error1)   %% ‚Üê raw Erlang record thrown
```

**After:**
```erlang
Error0 = beamtalk_error:new(does_not_understand, 'Integer'),
Error1 = beamtalk_error:with_selector(Error0, 'foo'),
beamtalk_error:raise(Error1)   %% ‚Üê Exception object thrown
```

Now everything that catches this error ‚Äî `on:do:`, REPL, production code ‚Äî receives a proper Exception object.

### 2. Codegen Changes

Generated Core Erlang code that raises errors changes from:
```erlang
%% Before: raw error record
call 'erlang':'error'(Error2)
```
to:
```erlang
%% After: raise wraps as object
call 'beamtalk_error':'raise'(Error2)
```

The `on:do:` catch clause changes in two ways:
1. `wrap` ‚Üí `ensure_wrapped` (idempotent ‚Äî handles both pre-wrapped and raw Erlang exceptions)
2. `matches_class` now receives the **wrapped object** instead of the raw error (semantic change ‚Äî enables hierarchy-aware matching on `$beamtalk_class`)

```erlang
%% Before: wrap at catch time, match on raw error
catch <Type, Error, Stack> ->
    let ExObj = call 'beamtalk_exception_handler':'wrap'(Error) in
    let Match = call 'beamtalk_exception_handler':'matches_class'(ExClass, Error) in
    case Match of
        true  -> apply HandlerFun (ExObj)
        false -> primop 'raw_raise'(Type, Error, Stack)
    end

%% After: ensure_wrapped (idempotent), match on wrapped object
catch <Type, Error, Stack> ->
    let ExObj = call 'beamtalk_exception_handler':'ensure_wrapped'(Error) in
    let Match = call 'beamtalk_exception_handler':'matches_class'(ExClass, ExObj) in
    case Match of
        true  -> apply HandlerFun (ExObj)
        false -> primop 'raw_raise'(Type, Error, Stack)
    end
```

`ensure_wrapped/1` is idempotent ‚Äî already-wrapped objects pass through, raw Erlang exceptions get wrapped:
```erlang
ensure_wrapped(#{'$beamtalk_class' := _} = Already) -> Already;
ensure_wrapped(#beamtalk_error{} = Error) -> wrap(Error);  %% safety net
ensure_wrapped(Other) -> wrap(Other).  %% raw Erlang exception
```

### 3. Error Class Hierarchy

Expand the hierarchy to distinguish error categories:

```
Exception                    (base ‚Äî catches everything in on:do:)
‚îî‚îÄ‚îÄ Error                    (non-resumable ‚Äî maps to Erlang's error class)
    ‚îú‚îÄ‚îÄ RuntimeError         (general runtime errors)
    ‚îÇ   ‚îú‚îÄ‚îÄ does_not_understand
    ‚îÇ   ‚îú‚îÄ‚îÄ arity_mismatch
    ‚îÇ   ‚îî‚îÄ‚îÄ immutable_value
    ‚îú‚îÄ‚îÄ TypeError            (type violations)
    ‚îÇ   ‚îî‚îÄ‚îÄ type_error
    ‚îú‚îÄ‚îÄ InstantiationError   (wrong construction method)
    ‚îÇ   ‚îî‚îÄ‚îÄ instantiation_error
    ‚îî‚îÄ‚îÄ IOError              (file system errors ‚Äî future)
        ‚îú‚îÄ‚îÄ file_not_found
        ‚îú‚îÄ‚îÄ permission_denied
        ‚îî‚îÄ‚îÄ io_error
```

Each stdlib class is a `.bt` file:

```beamtalk
// lib/RuntimeError.bt
Error subclass: RuntimeError
  describe => 'a RuntimeError'

// lib/TypeError.bt
Error subclass: TypeError
  describe => 'a TypeError'

// lib/InstantiationError.bt
Error subclass: InstantiationError
  describe => 'an InstantiationError'
```

The `kind ‚Üí class` mapping lives in `beamtalk_exception_handler`:

```erlang
wrap(#beamtalk_error{kind = Kind} = Error) ->
    ClassName = kind_to_class(Kind),
    #{'$beamtalk_class' => ClassName, error => Error}.

kind_to_class(does_not_understand) -> 'RuntimeError';
kind_to_class(arity_mismatch) -> 'RuntimeError';
kind_to_class(immutable_value) -> 'RuntimeError';
kind_to_class(type_error) -> 'TypeError';
kind_to_class(instantiation_error) -> 'InstantiationError';
kind_to_class(file_not_found) -> 'IOError';
kind_to_class(permission_denied) -> 'IOError';
kind_to_class(io_error) -> 'IOError';
kind_to_class(_) -> 'Error'.
```

### 4. `matches_class/2` Updated for Hierarchy

The exception matching in `on:do:` blocks respects the class hierarchy:

```erlang
%% Updated to handle wrapped objects AND hierarchy
matches_class(ExClass, #{'$beamtalk_class' := ObjClass, error := Error}) ->
    matches_hierarchy(ExClass, ObjClass, Error);
matches_class(ExClass, #beamtalk_error{} = Error) ->
    %% Fallback for unwrapped errors (shouldn't happen after Phase 1)
    matches_class(ExClass, wrap(Error));
matches_class(nil, _) -> true;
matches_class(_, _) -> true.  %% Unknown ‚Üí catch for safety

matches_hierarchy(nil, _, _) -> true;
matches_hierarchy('Exception', _, _) -> true;
matches_hierarchy('Error', _, _) -> true;  %% Error catches all Error subclasses
matches_hierarchy(FilterClass, ObjClass, _Error) when FilterClass =:= ObjClass -> true;
matches_hierarchy('RuntimeError', ObjClass, _Error) ->
    %% RuntimeError only catches RuntimeError, not TypeError/InstantiationError
    ObjClass =:= 'RuntimeError';
matches_hierarchy('TypeError', ObjClass, _Error) -> ObjClass =:= 'TypeError';
matches_hierarchy('InstantiationError', ObjClass, _Error) -> ObjClass =:= 'InstantiationError';
matches_hierarchy('IOError', ObjClass, _Error) -> ObjClass =:= 'IOError';
matches_hierarchy(_FilterClass, _ObjClass, _Error) -> false.
```

```beamtalk
// Catches all errors (including RuntimeError, TypeError, etc.)
[42 foo] on: Error do: [:e | e class]
// => RuntimeError

// Catches only TypeError
['hello' + 42] on: TypeError do: [:e | e message]
// => Expected Integer argument for '+' on String

// RuntimeError doesn't catch TypeError
['hello' + 42] on: RuntimeError do: [:e | e message]
// => (uncaught ‚Äî re-raises)
```

### 5. REPL: `_error` Binding for Post-Mortem Inspection

As a consequence of signal-time wrapping, the REPL naturally gets inspectable errors:

```erlang
%% beamtalk_repl_eval.erl catch clause ‚Äî Error IS already an object
catch error:Reason:_Stacktrace ->
    ExObj = beamtalk_exception_handler:ensure_wrapped(Reason),
    %% Bind to _error in session state
    NewBindings = maps:put('_error', ExObj, Bindings),
    FinalState = beamtalk_repl_state:set_bindings(NewBindings, NewState),
    {error, ExObj, FinalState}
```

```
> 42 foo
RuntimeError: Integer does not understand 'foo'
  Hint: Check spelling or use 'respondsTo:' to inspect available methods

> _error kind
// => does_not_understand

> _error message
// => Integer does not understand 'foo'

> _error errorClass
// => Integer

> _error selector
// => foo
```

### 6. Display Format

Error display changes from raw Erlang records to class-prefixed messages:

```
> 42 foo
RuntimeError: Integer does not understand 'foo'
  Hint: Check spelling or use 'respondsTo:' to inspect available methods

> Actor new
InstantiationError: Cannot create Actor with 'new'
  Hint: Use 'spawn' to create a new actor

> 'hello' + 42
TypeError: Expected Integer argument for '+' on String
```

Format: `<ClassName>: <message>\n  Hint: <hint>` (hint line only when present).

### 7. Non-REPL Contexts

**Production code with `on:do:`:**
```beamtalk
// Granular error handling
[parseUserInput: data] on: TypeError do: [:e |
  Logger warn: 'Bad input: ' , e message
  defaultValue
]
```

**Erlang interop (try/catch):**
```erlang
%% Erlang code catching Beamtalk errors
try SomeBeamtalkCall of
    Result -> Result
catch
    error:#{'$beamtalk_class' := Class, error := Error} ->
        %% Full access to structured error
        io:format("~s: ~s~n", [Class, Error#beamtalk_error.message]);
    error:RawReason ->
        %% Non-Beamtalk error
        io:format("Erlang error: ~p~n", [RawReason])
end
```

**Supervision:** No change ‚Äî OTP supervisors see `{error, WrappedObject, [...]}` instead of `{error, #beamtalk_error{}, [...]}`. The crash reason is still pattern-matchable.

## Prior Art

### Pharo Smalltalk
- **Errors are always objects** ‚Äî created at signal time, not catch time
- `MessageNotUnderstood`, `ZeroDivide`, etc. are subclasses of `Error`
- `doesNotUnderstand:` creates a `MessageNotUnderstood` and calls `signal` on it
- The debugger receives the same object the handler would ‚Äî no wrapping step
- **Exception class hierarchy** enables granular matching: `on: ZeroDivide do:` vs `on: Error do:`
- **Resumption protocol**: `resume:`, `retry`, `pass` ‚Äî handlers can resume execution
- **Adopted:** Signal-time creation, class hierarchy, `on:do:` matching
- **Deferred:** Resumption protocol (requires VM-level support Beamtalk can't easily provide on BEAM)

### Elixir
- Exceptions are **structs** (`%RuntimeError{message: "..."}`) ‚Äî always objects
- Raised with `raise` which creates the struct: `raise ArgumentError, message: "bad"` 
- Caught by `try/rescue` with class matching: `rescue e in ArgumentError ->`
- Rich hierarchy: `RuntimeError`, `ArithmeticError`, `ArgumentError`, `KeyError`, etc.
- No signal-time vs catch-time distinction ‚Äî the struct IS the exception from creation
- **Adopted:** Class-based matching in rescue/on:do:, named error classes

### Ruby
- Exceptions are objects created at raise time: `raise TypeError, "wrong type"`
- Class hierarchy: `Exception ‚Üí StandardError ‚Üí RuntimeError`, `TypeError`, `IOError`, etc.
- `$!` is set during rescue but cleared after ‚Äî **Pry** stores as `_ex_` for inspection
- **Adopted:** `_error` binding (like Pry's `_ex_`), familiar class names
- **Lesson:** IRB's lack of `_ex_` is a known limitation that Pry fixes

### Erlang
- Exceptions are raw terms: `error(badarith)`, `throw({not_found, Key})`
- No class hierarchy ‚Äî everything is atoms/tuples
- Shell displays raw terms: `** exception error: badarith`
- **Lesson:** This is the anti-pattern. Raw term display and lack of structure is what we're improving on.

### Gleam
- **No exceptions at all** ‚Äî uses `Result(Ok, Error)` types for all error handling
- Errors are explicit return values: `case file.read(path) { Ok(data) -> ... Error(e) -> ... }`
- No class hierarchy for errors ‚Äî errors are just values in the Result type
- **Rejected approach for Beamtalk:** Beamtalk already uses Erlang's exception mechanism throughout. Converting to Result types would require rewriting all dispatch, runtime, and codegen. However, Gleam demonstrates that pure functional error handling IS viable on BEAM.
- **Lesson:** Result types are a valid BEAM approach but incompatible with Smalltalk's `on:do:` + supervision model that Beamtalk already uses.

### Summary

| Feature | Smalltalk | Elixir | Ruby | Gleam | Erlang | **Beamtalk (proposed)** |
|---------|-----------|--------|------|-------|--------|------------------------|
| Errors are objects | ‚úÖ always | ‚úÖ structs | ‚úÖ always | ‚ùå Result types | ‚ùå raw terms | **‚úÖ signal-time** |
| Class hierarchy | ‚úÖ rich | ‚úÖ rich | ‚úÖ rich | ‚ùå none | ‚ùå none | **‚úÖ RuntimeError, TypeError, etc.** |
| Signal-time creation | ‚úÖ yes | ‚úÖ yes | ‚úÖ yes | N/A | N/A | **‚úÖ via raise/1** |
| Class-based matching | ‚úÖ on:do: | ‚úÖ rescue | ‚úÖ rescue | ‚ùå pattern match | ‚ùå pattern match | **‚úÖ on:do: + hierarchy** |
| REPL inspection | ‚úÖ debugger | ‚ùå manual | ‚úÖ Pry _ex_ | ‚ùå N/A | ‚ùå none | **‚úÖ _error binding** |
| Resumption | ‚úÖ resume: | ‚ùå no | ‚ùå no | ‚ùå no | ‚ùå no | **‚ùå deferred** |

## User Impact

### Newcomer (from Python/JS/Ruby)
- **Signal-time objects** ‚Äî transparent. They see `RuntimeError`, `TypeError` ‚Äî familiar concepts.
- **`_error` binding** ‚Äî matches Python's implicit `__traceback__` and Pry's `_ex_`
- **Inspectable errors** ‚Äî `_error kind`, `_error hint` ‚Äî interactive learning
- Errors remain visually distinct from results (no confusion about success/failure)

### Smalltalk Developer
- **"Everything is an object" finally applies to errors** ‚Äî at raise time, not just inside `on:do:`
- **Class hierarchy** ‚Äî `on: TypeError do:` works like Pharo's `on: ZeroDivide do:`
- **Missing:** Resumption protocol (no `resume:`, `retry`). But BEAM's "let it crash" + supervision is the pragmatic replacement.
- `_error` is a REPL convenience ‚Äî Smalltalk developers would expect the debugger instead

### Erlang/BEAM Developer
- **BEAM mechanism unchanged** ‚Äî `error/1` throws the term, try/catch catches it
- The thrown term is now a tagged map instead of a record ‚Äî can pattern match on `$beamtalk_class`
- **Erlang interop**: Erlang code catching Beamtalk errors sees tagged maps. Can extract inner `#beamtalk_error{}` via `error` key.
- **Supervision**: crash reasons are still inspectable ‚Äî map structure is actually easier to read in crash logs than raw record tuples
- Raw Erlang exceptions (`badarith`, `badmatch`) are still caught and wrapped at the `on:do:` catch site via `ensure_wrapped/1`

### Production Operator
- **Structured error logging** ‚Äî filter by `$beamtalk_class` in crash logs
- **Granular error handling** ‚Äî `on: IOError do:` for I/O, `on: TypeError do:` for validation
- **No performance impact** ‚Äî wrapping happens once at raise time, on the error path only

## Steelman Analysis

### "Keep Catch-Time Wrapping" (Extend Current Approach)

| Cohort | Strongest argument |
|--------|-------------------|
| ‚öôÔ∏è **BEAM veteran** | "Signal-time wrapping means every `error/1` call changes. Catch-time is more conservative ‚Äî just add wrapping where needed." |
| üè≠ **Operator** | "Fewer changes = fewer regressions. Catch-time wrapping at REPL + on:do: covers the important cases." |
| üé® **Language designer** | "Keeping #beamtalk_error{} as the thrown term means Erlang code can pattern match on it without learning tagged maps." |

**Rebuttal:** Catch-time wrapping means N catch sites, each needing `wrap/1`. Signal-time means 1 `raise/1` function that wraps once. And the Erlang interop argument cuts both ways ‚Äî tagged maps with `$beamtalk_class` are MORE informative than raw records for Erlang code reading crash logs.

### "Errors as Results, Not Exceptions" (Functional Approach)

| Cohort | Strongest argument |
|--------|-------------------|
| ‚öôÔ∏è **BEAM veteran** | "Elixir uses `{:ok, value}` / `{:error, reason}` ‚Äî explicit error handling is better than exceptions." |
| üé© **Smalltalk purist** | "In Smalltalk, `doesNotUnderstand:` IS a message send that returns a value. Errors can be values." |
| üé® **Language designer** | "No special error path needed. Simpler runtime. Everything is a message send." |

**Rebuttal:** Beamtalk already uses exceptions (Erlang's error mechanism) everywhere. Converting to result types would require rewriting all dispatch, all runtime code, and all codegen. The `on:do:` + supervision model is well-proven on BEAM.

### Tension Points
- **Signal-time wrapping changes the thrown term type** ‚Äî Erlang interop code that catches `#beamtalk_error{}` would need updating
- **Hierarchy depth** ‚Äî Some prefer a flat `Error` over `RuntimeError ‚Üí Error ‚Üí Exception` nesting
- **Resumption** ‚Äî Smalltalk purists want `resume:` / `retry` but BEAM can't easily support it

## Alternatives Considered

### Alternative A: Catch-Time Wrapping Only (Extend Current)
Add `wrap/1` calls to REPL and recommend it in production try/catch. Keep `error(#beamtalk_error{})` as the thrown term.
```erlang
%% Each catch site wraps independently
catch error:Reason:_ST ->
    ExObj = beamtalk_exception_handler:wrap(Reason),  %% needed at every catch
```
**Rejected because:** Multiple wrapping sites to maintain. Inconsistent ‚Äî sometimes you get an object, sometimes a raw record, depending on who catches it. Not "everything is an object."

### Alternative B: Replace `#beamtalk_error{}` Record Entirely
Don't use Erlang records at all ‚Äî construct the Exception tagged map directly in `beamtalk_error:new/2`:
```erlang
new(Kind, Class) ->
    #{'$beamtalk_class' => kind_to_class(Kind),
      kind => Kind, class => Class, message => generate_message(Kind, Class, undefined),
      hint => undefined, selector => undefined, details => #{}}.
```
**Rejected because:** Too invasive. The `#beamtalk_error{}` record provides compile-time field checking in Erlang code (records are tuples with named fields). Keeping the record as the internal representation and wrapping in `raise/1` preserves this safety while presenting objects to Beamtalk code.

### Alternative C: Return Error Objects as REPL Results
When the REPL catches an error, return it as the result value instead of on the error path:
```
> 42 foo
=> RuntimeError: Integer does not understand 'foo'
```
**Rejected because:** Blurs success/error distinction. Users can't tell if an expression succeeded or failed. The REPL protocol distinction (`type: "result"` vs `type: "error"`) is valuable for CLI rendering (colors, exit codes).

### Alternative D: Minimal REPL Fix Only
Fix the `format_error_message/1` bug directly ‚Äî add a clause to extract `#beamtalk_error{}` from `{eval_error, error, Reason}`:
```erlang
format_error_message({eval_error, error, #beamtalk_error{} = Error}) ->
    iolist_to_binary(beamtalk_error:format(Error));
```
**Not rejected ‚Äî but insufficient.** This fixes the display bug (~5 lines, immediate value) and should be done regardless. However, it doesn't address the core issue: errors are not objects outside `on:do:`, there's no `_error` inspection, and no class hierarchy. This is a good first commit within Phase 1, not an alternative to the decision.

## Consequences

### Positive
- **Errors are objects everywhere** ‚Äî consistent with "everything is an object" principle
- **Single wrapping point** ‚Äî `raise/1` wraps once; no per-catch-site wrapping needed
- **Error class hierarchy** ‚Äî `on: TypeError do:` enables granular error handling
- **REPL inspection** ‚Äî `_error` binding for post-mortem debugging
- **Better display** ‚Äî `RuntimeError: Integer does not understand 'foo'` instead of leaked Erlang syntax
- **Erlang interop improved** ‚Äî tagged maps in crash logs are more readable than record tuples
- **Foundation for tooling** ‚Äî IDE error inspection, structured logging, error aggregation

### Negative
- **All `error(#beamtalk_error{})` sites must change** ‚Äî ~54 throw sites in 9 runtime `.erl` files, plus ~17 codegen generation sites in Rust
- **Erlang pattern matching changes** ‚Äî Code matching `#beamtalk_error{}` in catch must match tagged maps instead
- **More stdlib classes** ‚Äî RuntimeError, TypeError, InstantiationError (~3 new `.bt` files)
- **`_error` is a magic variable** ‚Äî implicit binding may surprise some users
- **No resumption protocol** ‚Äî Smalltalk's `resume:` / `retry` not supported on BEAM
- **OTP crash log format changes** ‚Äî Observer, sasl reports, and recon will display tagged maps instead of record tuples. Operators need updated documentation.
- **Bootstrap ordering concern (Phase 2)** ‚Äî Error subclass processes (RuntimeError, TypeError) may not exist when the first error is raised during stdlib loading. Phase 1 is safe (wraps as `'Exception'`); Phase 2's `kind_to_class/1` mapping must tolerate missing class processes or use fallback wrapping.

### Neutral
- **REPL protocol unchanged** ‚Äî `{"type": "error"}` still used for error display
- **`#beamtalk_error{}` record unchanged** ‚Äî still used internally, just wrapped before throwing
- **Supervision behavior unchanged** ‚Äî OTP sees a different crash reason term but behavior is the same
- **`on:do:` semantics unchanged** ‚Äî handlers still receive Exception objects, just no wrapping step

## Implementation

### Phase 1: Signal-Time Wrapping + REPL `_error`
**Effort: M**

**Components affected:** Runtime (Erlang), REPL, Codegen (Rust)

1. **`beamtalk_error.erl`** ‚Äî Add `raise/1` that wraps and throws
2. **Runtime `.erl` files** (~54 throw sites across 9 files) ‚Äî Replace `error(ErrorRecord)` with `beamtalk_error:raise(ErrorRecord)`:
   - `beamtalk_dispatch.erl` ‚Äî method not found
   - `beamtalk_actor.erl` ‚Äî actor_dead, does_not_understand
   - `beamtalk_list_ops.erl` ‚Äî type_error, bounds errors (19 sites)
   - `beamtalk_set_ops.erl` ‚Äî type errors
   - `beamtalk_file.erl` ‚Äî IO errors (11 sites)
   - `beamtalk_tuple_ops.erl` ‚Äî type errors (5 sites)
   - `beamtalk_string_ops.erl` ‚Äî type errors
   - `beamtalk_object_class.erl` ‚Äî class registration, method errors (8 sites)
   - `beamtalk_primitive.erl` ‚Äî primitive dispatch errors
   - `beamtalk_exception_handler.erl` ‚Äî signal/1, signal_message/1
3. **`beamtalk_exception_handler.erl`** ‚Äî Add `ensure_wrapped/1` (idempotent wrapper for Erlang exceptions)
4. **Codegen** (`dispatch_codegen.rs`, `intrinsics.rs`, `gen_server/*.rs`, `primitive_implementations.rs`, `value_type_codegen.rs`) ‚Äî Two kinds of changes:
   - Direct error generation: `call 'erlang':'error'(Error2)` ‚Üí `call 'beamtalk_error':'raise'(Error2)` (~17 sites)
   - Dispatch error conversion: `<{'error', Error, _}> -> call 'erlang':'error'(Error)` ‚Üí `call 'beamtalk_error':'raise'(Error)` (~3 sites in dispatch_codegen.rs)
5. **`on:do:` codegen** (`exception_handling.rs`) ‚Äî Use `ensure_wrapped` instead of `wrap`, pass wrapped object to `matches_class`
6. **REPL** (`beamtalk_repl_eval.erl`, `beamtalk_repl_server.erl`) ‚Äî Catch wrapped objects, bind to `_error`, format via `printString`. Also fix `format_error_message/1` for `{eval_error, error, #beamtalk_error{}}` as immediate improvement.
7. **Dialyzer** ‚Äî Update type specs for `matches_class/2`, `wrap/1`, `ensure_wrapped/1` to reflect map return types
8. **Tests** ‚Äî Update exception E2E tests, add `_error` REPL test

### Phase 2: Error Class Hierarchy
**Effort: S**

**Note:** Phase 2 introduces a bootstrap ordering concern ‚Äî `kind_to_class/1` maps error kinds to class names like `'RuntimeError'`, but these class processes may not exist during early startup (before stdlib loads). The wrapping itself (tagged map creation) works without the class process, but dispatch on the wrapped object would fail. Implementation must either: (a) ensure error subclasses load before any user code, or (b) have `kind_to_class/1` fall back to `'Error'` if the class isn't registered yet.

**Note:** The `matches_hierarchy/3` implementation shown in ¬ß4 is deliberately hardcoded for the initial set of error classes. True dynamic hierarchy walking for value types is not yet defined in ADR 0006 (Unified Method Dispatch). If user-defined exception subclasses are needed in the future, this should be revisited with a proper hierarchy walking mechanism. For the initial 4 error classes (RuntimeError, TypeError, InstantiationError, IOError), hardcoding is pragmatic and sufficient.

1. **New stdlib files**: `lib/RuntimeError.bt`, `lib/TypeError.bt`, `lib/InstantiationError.bt`
2. **`beamtalk_exception_handler.erl`** ‚Äî Add `kind_to_class/1` mapping in `wrap/1`
3. **`matches_class/2`** ‚Äî Hierarchy-aware matching (RuntimeError is-a Error is-a Exception)
4. **Tests** ‚Äî `on: TypeError do:` matching, `on: Error do:` catches all subclasses, class display in errors

### Phase 3: Extended Error Classes (deferred)
**Effort: S**

1. `IOError` for file system errors (`file_not_found`, `permission_denied`, `io_error`)
2. `ConcurrencyError` for actor/future errors (`actor_dead`, `timeout`, `future_not_awaited`)
3. Consider `MessageNotUnderstood` as RuntimeError subclass (closer to Smalltalk)
4. Expand kind-to-class mapping

### Phase 4: Resumption Protocol (future, needs design)
**Effort: L ‚Äî Separate ADR required**

Smalltalk's `resume:`, `retry`, `pass` would need:
- Handler stack implementation in the runtime
- Continuation capture (difficult on BEAM)
- Alternative: Use BEAM's process model ‚Äî supervisor restarts = Erlang-native "retry"

## Migration Path

### Runtime Erlang Code
All `error(#beamtalk_error{})` ‚Üí `beamtalk_error:raise(#beamtalk_error{})`. Mechanical replacement.

### Generated Code
Codegen changes from `call 'erlang':'error'(ErrorVar)` to `call 'beamtalk_error':'raise'(ErrorVar)`. Recompile all `.bt` files.

### Erlang Interop
Code that catches Beamtalk errors via pattern matching on `#beamtalk_error{}` in catch clauses must update to match tagged maps:
```erlang
%% Before
catch error:#beamtalk_error{kind = Kind} -> ...

%% After
catch error:#{'$beamtalk_class' := _, error := #beamtalk_error{kind = Kind}} -> ...
```

### Existing Tests
- `tests/e2e/cases/exceptions.bt` ‚Äî Should pass unchanged (handlers receive same object)
- `tests/e2e/cases/errors.bt` ‚Äî `ERROR:` assertion format may need updating
- Runtime tests that catch `#beamtalk_error{}` directly ‚Äî Update to match wrapped objects

## References
- Related ADRs: [ADR 0005](0005-beam-object-model-pragmatic-hybrid.md) (object model), [ADR 0006](0006-unified-method-dispatch.md) (dispatch), [ADR 0007](0007-compilable-stdlib-with-primitive-injection.md) (stdlib)
- Existing implementation: `beamtalk_exception_handler.erl`, `lib/Exception.bt`, `lib/Error.bt`
- Design doc: `docs/internal/design-self-as-object.md` (¬ß3.8 Error Taxonomy)
- Test coverage: `tests/e2e/cases/exceptions.bt`, `tests/e2e/cases/errors.bt`, `tests/e2e/cases/error_method.bt`
- Prior art: [Pharo Exception handling](https://docs.huihoo.com/smalltalk/pharo/MOOC/PharoMOOC/Week5/C019-W5S04-Exceptions.pdf), [Taking Exception to Smalltalk](http://laputan.org/pub/papers/ExceptionHandlingPart1.pdf), [Elixir exceptions](https://hexdocs.pm/elixir/main/try-catch-and-rescue.html), [Pry `_ex_`](https://github.com/pry/pry)
