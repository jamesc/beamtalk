// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

// Auto-tests for examples in docs/beamtalk-language-features.md


TestCase subclass: LanguageFeaturesDocTest

  testStringEncodingAndUtf8 =>
    self assert: ("Hello" length) equals: 5.
    self assert: ("世界" length) equals: 2.
    // Slicing by grapheme
    self assert: ("Hello" at: 1) equals: "H".
    self assert: ("世界" at: 1) equals: "世".
    // Case conversion
    self assert: ("HELLO" lowercase) equals: "hello".
    self assert: ("straße" uppercase) equals: "STRASSE"

  testCoreSyntaxBinaryOperators =>
    // Exponentiation
    self assert: (2 ** 10) equals: 1024.
    // Multiplicative
    self assert: (3 * 4) equals: 12.
    self assert: (10 / 2) equals: 5 asFloat.
    self assert: (17 % 5) equals: 2.
    // Additive
    self assert: (3 + 4) equals: 7.
    self assert: (10 - 3) equals: 7.
    self assert: "Hello" ++ " World" equals: "Hello World".
    // Comparison
    self assert: (3 < 5).
    self assert: (5 > 3).
    self assert: (3 <= 3).
    self assert: (5 >= 3).
    // Equality
    self assert: (5 =:= 5).
    self assert: (5 == 5.0).
    self assert: (5 /= 6).
    self assert: (5 =/= 6)

  testGradualTyping =>
    typedDocMath := TypedMath new.
    self assert: (typedDocMath identity: 7) equals: 7.
    self assert: (typedDocMath sum: 2 with: 5) equals: 7.
    self assert: (typedDocMath maybeName: false) equals: "none".
    typedDocAccount := TypedAccount spawn.
    self assert: ((typedDocAccount deposit: 8) await) equals: 8.
    self assert: (typedDocAccount balance await) equals: 8

  testBlocksClosures =>
    // Block with arguments
    self assert: ([:x :y | x + y] value: 3 value: 4) equals: 7.
    // Block with local variables
    myBlock := [:x | temp := x * 2. temp + 1].
    self assert: (myBlock value: 5) equals: 11

  testPatternMatchingMatchExpression =>
    // Variable binding in patterns
    self assert: (42 match: [n -> n + 1]) equals: 43.
    // Match on computed expression
    self assert: ((3 + 4) match: [7 -> "correct"; _ -> "wrong"]) equals: "correct".
    // Integer literal matching
    self assert: (1 match: [1 -> "one"; 2 -> "two"; _ -> "other"]) equals: "one".
    self assert: (2 match: [1 -> "one"; 2 -> "two"; _ -> "other"]) equals: "two".
    self assert: (3 match: [1 -> "one"; 2 -> "two"; _ -> "other"]) equals: "other".
    // Symbol matching
    self assert: (#ok match: [#ok -> "success"; #error -> "failure"; _ -> "unknown"]) equals: "success".
    // String matching
    self assert: ("hello" match: ["hello" -> "hi"; _ -> "huh?"]) equals: "hi".
    // Negative number patterns
    self assert: (-1 match: [-1 -> "minus one"; 0 -> "zero"; _ -> "other"]) equals: "minus one".
    self assert: (0 match: [-1 -> "minus one"; 0 -> "zero"; _ -> "other"]) equals: "zero".
    // Guard clauses with when:
    self assert: (10 match: [n when: [n > 100] -> "big"; n when: [n > 5] -> "medium"; _ -> "small"]) equals: "medium".
    // Wildcard match
    self assert: (42 match: [_ -> "matched"]) equals: "matched"

  testDestructuringInMatchArms =>
    // Variable captures the matched value
    self assert: (42 match: [x -> x + 1]) equals: 43.
    // Multiple arms with variable binding
    self assert: ("hello" match: [s -> s size]) equals: 5

  testStandardLibraryStream =>
    // Terminal forces computation through the pipeline
    self assert: (((Stream from: 1) select: [:n | n isEven]) take: 5) equals: #(2, 4, 6, 8, 10).
    self assert: ((Stream on: #(1, 2, 3, 4)) inject: 0 into: [:sum :n | sum + n]) equals: 10.
    // Stream printString — pipeline inspection
    self assert: ((Stream from: 1) printString) notNil.
    self assert: ((Stream on: #(1, 2, 3)) printString) notNil.
    self assert: (((Stream from: 1) select: [:n | n isEven]) printString) notNil.
    // Eager vs Lazy boundary
    self assert: (#(1, 2, 3, 4, 5) select: [:n | n > 2]) equals: #(3, 4, 5)

  testTestingFrameworkExpressionTests =>
    // From the expression tests example
    self assert: (1 + 2) equals: 3.
    self assert: ("hello" size) equals: 5.
    self assert: "hello" ++ " world" equals: "hello world"
