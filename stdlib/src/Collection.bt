// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

/// Collection — Abstract superclass for all collections.
///
/// Provides the shared iteration and query protocol for List, Set,
/// Dictionary, and Tuple. Cannot be instantiated directly.
///
/// Subclasses must implement `size` and `do:` at minimum.
/// All other iteration methods have default implementations built
/// in pure Beamtalk on those two primitives.
///
/// ## Protocol
/// ```beamtalk
/// #(1, 2, 3) isEmpty           // => false
/// #(1, 2, 3) includes: 2       // => true
/// #(1, 2, 3) collect: [:x | x * 2]  // => #(2, 4, 6)
/// ```
abstract Object subclass: Collection

  // === Abstract protocol (subclasses must implement) ===

  /// Return the number of elements.
  size -> Integer => self subclassResponsibility

  /// Iterate over each element, evaluating `block` with each one.
  do: block: Block -> Nil => self subclassResponsibility

  /// Return a developer-readable string representation.
  printString -> String => self subclassResponsibility

  // === Species protocol ===

  /// Return the class used to build results from collection operations.
  ///
  /// Used by `collect:`, `select:`, and `reject:` to return the same
  /// collection type as the receiver. Sealed subclasses override this.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2) species         // => List
  /// #[1, 2] species         // => Array
  /// ```
  species => self class

  /// Factory method — create a collection of this type from a list.
  ///
  /// Default implementation returns the list as-is, giving `List` results
  /// for custom user-defined Collection subclasses. Sealed built-in types
  /// (List, Set, Array, Tuple, String) override this to produce their own type.
  ///
  /// ## Examples
  /// ```beamtalk
  /// List withAll: #(1, 2, 3)         // => #(1, 2, 3)
  /// Array withAll: #(1, 2, 3)        // => #[1, 2, 3]
  /// ```
  class withAll: list: List => list

  // === Shared protocol (implemented in terms of abstract methods) ===

  /// Test if the collection has no elements.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #() isEmpty                  // => true
  /// #(1) isEmpty                 // => false
  /// ```
  isEmpty -> Boolean => self size =:= 0

  /// Test if the collection has at least one element.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1) isNotEmpty              // => true
  /// #() isNotEmpty               // => false
  /// ```
  isNotEmpty -> Boolean => self isEmpty not

  /// Test if the collection contains the given element.
  ///
  /// Default implementation iterates with `do:` and returns early on match.
  /// Subclasses may override with more efficient lookup.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 3) includes: 2      // => true
  /// #(1, 2, 3) includes: 9      // => false
  /// ```
  includes: element -> Boolean =>
    self do: [:each | each =:= element ifTrue: [^true]].
    false

  /// Reduce the collection with an accumulator.
  ///
  /// Evaluates `block` with `(accumulator, element)` for each element.
  /// Returns the final accumulator value.
  ///
  /// Kept as `@primitive` because the pure-BT implementation using `do:` with
  /// local-variable mutation does not work for abstract-class methods: the
  /// compiler generates `lists:foreach` (no state threading) instead of
  /// `lists:foldl`.  The Erlang helper calls the block as `Block(Acc, Elem)`
  /// (accumulator first) to match the Beamtalk `block value: acc value: each`
  /// convention expected by `collect:`, `select:`, and `reject:`.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 3) inject: 0 into: [:sum :x | sum + x]  // => 6
  /// ```
  inject: initial into: block: Block => @primitive "inject:into:"

  /// Collect results of evaluating `block` on each element.
  ///
  /// Returns a collection of the same type as the receiver (species pattern).
  /// Builds the result in reverse using `addFirst:` then converts via `species withAll:`.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 3) collect: [:x | x * 2]  // => #(2, 4, 6)
  /// ```
  collect: block: Block =>
    result := (self inject: #() into: [:acc :each | acc addFirst: (block value: each)]) reversed.
    self species withAll: result

  /// Select elements for which `block` returns true.
  ///
  /// Returns a collection of the same type as the receiver (species pattern).
  /// Builds the result in reverse using `addFirst:` then converts via `species withAll:`.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 3, 4) select: [:x | x > 2]  // => #(3, 4)
  /// ```
  select: block: Block =>
    result := (self inject: #() into: [:acc :each |
      (block value: each) ifTrue: [acc addFirst: each] ifFalse: [acc]
    ]) reversed.
    self species withAll: result

  /// Reject elements for which `block` returns true.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 3, 4) reject: [:x | x > 2]  // => #(1, 2)
  /// ```
  reject: block: Block =>
    self select: [:each | (block value: each) not]

  /// Find the first element for which `block` returns true.
  ///
  /// Returns nil if no element matches. Uses `^` (non-local return) for
  /// early exit — this compiles to throw/catch on BEAM.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 3) detect: [:x | x > 1]     // => 2
  /// ```
  detect: block: Block =>
    self do: [:each | (block value: each) ifTrue: [^each]].
    nil

  /// Find the first element matching `block`, or evaluate `noneBlock` if none.
  ///
  /// Uses `^` (non-local return) for early exit — compiles to throw/catch on BEAM.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2) detect: [:x | x > 5] ifNone: [0]  // => 0
  /// ```
  detect: block: Block ifNone: noneBlock: Block =>
    self do: [:each | (block value: each) ifTrue: [^each]].
    noneBlock value

  /// Test if any element satisfies `block`.
  ///
  /// Uses `^` (non-local return) for early exit — compiles to throw/catch on BEAM.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 3) anySatisfy: [:x | x > 2]  // => true
  /// ```
  anySatisfy: block: Block -> Boolean =>
    self do: [:each | (block value: each) ifTrue: [^true]].
    false

  /// Test if all elements satisfy `block`.
  ///
  /// Uses `^` (non-local return) for early exit — compiles to throw/catch on BEAM.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(2, 4, 6) allSatisfy: [:x | x isEven]  // => true
  /// ```
  allSatisfy: block: Block -> Boolean =>
    self do: [:each | (block value: each) ifFalse: [^false]].
    true

  /// Return a string representation.
  asString -> String => self printString
