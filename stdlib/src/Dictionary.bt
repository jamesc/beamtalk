// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

/// Dictionary — Immutable key-value collection.
///
/// Dictionaries are backed by Erlang maps. Operations that "modify"
/// a dictionary return a new dictionary — the original is unchanged.
///
/// ## BEAM Mapping
/// Beamtalk dictionaries map directly to Erlang maps.
///
/// ## Examples
/// ```beamtalk
/// #{#name => "Alice"} class                   // => Dictionary
/// #{#name => "Alice"} at: #name               // => "Alice"
/// #{#a => 1} at: #b put: 2                    // => #{#a => 1, #b => 2}
/// ```
sealed Collection subclass: Dictionary

  /// Number of key-value pairs.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #{#a => 1, #b => 2} size                   // => 2
  /// ```
  size -> Integer => @primitive "size"

  /// Return a list of all keys.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #{#a => 1, #b => 2} keys
  /// ```
  keys -> List => @primitive "keys"

  /// Return a list of all values.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #{#a => 1, #b => 2} values
  /// ```
  values -> List => @primitive "values"

  /// Return the value associated with `key`. Raises an error if not found.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #{#name => "Alice"} at: #name              // => "Alice"
  /// ```
  at: key => @primitive "at:"

  /// Return the value for `key`, or evaluate `block` if absent.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #{#a => 1} at: #b ifAbsent: [0]            // => 0
  /// ```
  at: key ifAbsent: block: Block => @primitive "at:ifAbsent:"

  /// Return a new dictionary with `key` mapped to `value`.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #{#a => 1} at: #b put: 2                   // => #{#a => 1, #b => 2}
  /// ```
  at: key put: value -> Dictionary => @primitive "at:put:"

  /// Test if the dictionary contains the given key.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #{#a => 1} includesKey: #a                 // => true
  /// #{#a => 1} includesKey: #b                 // => false
  /// ```
  includesKey: key -> Boolean => @primitive "includesKey:"

  /// Return a new dictionary without the given key.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #{#a => 1, #b => 2} removeKey: #a          // => #{#b => 2}
  /// ```
  removeKey: key -> Dictionary => @primitive "removeKey:"

  /// Merge another dictionary into the receiver (other's values win on conflict).
  ///
  /// ## Examples
  /// ```beamtalk
  /// #{#a => 1} merge: #{#b => 2}               // => #{#a => 1, #b => 2}
  /// ```
  merge: other: Dictionary -> Dictionary => @primitive "merge:"

  /// Test if the dictionary contains the given value.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #{#a => 1, #b => 2} includes: 1     // => true
  /// #{#a => 1} includes: 3              // => false
  /// ```
  includes: value -> Boolean => @primitive "includes:"

  /// Iterate over each value, evaluating `block` with each one.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #{#a => 1, #b => 2} do: [:v | Transcript show: v]
  /// ```
  do: block: Block -> Nil => @primitive "do:"

  /// Map `block` over each value, returning a new Dictionary with the
  /// same keys and transformed values.
  ///
  /// Overrides `Collection>>collect:` — for a Dictionary, the result
  /// preserves keys rather than collecting values into a list.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #{#a => 1, #b => 2} collect: [:v | v * 10]  // => #{#a => 10, #b => 20}
  /// ```
  collect: block: Block -> Dictionary =>
    dict := self.
    self keys inject: #{} into: [:k :acc |
      acc at: k put: (block value: (dict at: k))
    ]

  /// Iterate over each key-value pair, evaluating `block` with key and value.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #{#a => 1} keysAndValuesDo: [:k :v | Transcript show: k]
  /// ```
  keysAndValuesDo: block: Block -> Nil =>
    self stream do: [:assoc | block value: assoc key value: assoc value]

  /// Return a string representation using Beamtalk syntax.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #{#a => 1} printString                     // => "#{#a => 1}"
  /// ```
  printString -> String => @primitive "printString"

  /// Return a lazy Stream over the dictionary entries as Associations.
  ///
  /// ## Examples
  /// ```beamtalk
  /// (#{#a => 1} stream) asList
  /// ```
  stream -> Stream => @primitive "stream"


