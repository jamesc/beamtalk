// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

/// List — Ordered collection of elements.
///
/// Lists in Beamtalk are Erlang linked lists, created with `#()` syntax.
/// Fast prepend (O(1)), sequential access. Use for stack-like and
/// functional patterns.
///
/// ## BEAM Mapping
/// Beamtalk lists map directly to Erlang lists.
///
/// ## Examples
/// ```beamtalk
/// #(1, 2, 3) class         // => List
/// #(1, 2, 3) size          // => 3
/// #(1, 2, 3) first         // => 1
/// #(1, 2) ++ #(3, 4)       // => #(1, 2, 3, 4)
/// ```
sealed Collection subclass: List
  /// Number of elements in the list.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 3) size          // => 3
  /// #() size                 // => 0
  /// ```
  size -> Integer => @primitive "size"

  /// Test if the list has no elements.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #() isEmpty              // => true
  /// #(1) isEmpty             // => false
  /// ```
  isEmpty -> Boolean => @primitive "isEmpty"

  /// Return the first element.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 3) first         // => 1
  /// ```
  first => @primitive "first"

  /// Return all elements except the first (the tail).
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 3) rest          // => #(2, 3)
  /// ```
  rest -> List => @primitive "rest"

  /// Return the last element.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 3) last          // => 3
  /// ```
  last => @primitive "last"

  /// Return the element at the given 1-based index.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(10, 20, 30) at: 2      // => 20
  /// ```
  at: index: Integer => @primitive "at:"

  /// Test if the list contains the given item.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 3) includes: 2   // => true
  /// #(1, 2, 3) includes: 9   // => false
  /// ```
  includes: item -> Boolean => @primitive "includes:"

  /// Sort the list in ascending order.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(3, 1, 2) sort          // => #(1, 2, 3)
  /// ```
  sort -> List => @primitive "sort"

  /// Sort the list using a custom comparator block.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(3, 1, 2) sort: [:a :b | a > b]   // => #(3, 2, 1)
  /// ```
  sort: comparator: Block -> List => @primitive "sort:"

  /// Reverse the order of elements.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 3) reversed      // => #(3, 2, 1)
  /// ```
  reversed -> List => @primitive "reversed"

  /// Remove duplicate elements.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 2, 3) unique     // => #(1, 2, 3)
  /// ```
  unique -> List => @primitive "unique"

  /// Find the first element for which `block` returns true.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 3) detect: [:x | x > 1]   // => 2
  /// ```
  detect: block: Block => @primitive "detect:"

  /// Find the first element matching `block`, or evaluate `default` if none.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2) detect: [:x | x > 5] ifNone: [0]   // => 0
  /// ```
  detect: block: Block ifNone: default: Block => @primitive "detect:ifNone:"

  /// Iterate over each element, evaluating `block` with each one.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 3) do: [:x | Transcript show: x]
  /// ```
  do: block: Block -> Nil => @primitive "do:"

  /// Collect results of evaluating `block` on each element.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 3) collect: [:x | x * 2]   // => #(2, 4, 6)
  /// ```
  collect: block: Block -> List => @primitive "collect:"

  /// Select elements for which `block` returns true.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 3, 4) select: [:x | x > 2]   // => #(3, 4)
  /// ```
  select: block: Block -> List => @primitive "select:"

  /// Reject elements for which `block` returns true.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 3, 4) reject: [:x | x > 2]   // => #(1, 2)
  /// ```
  reject: block: Block -> List => @primitive "reject:"

  /// Reduce the list with an accumulator. Evaluates `block` with accumulator and each element.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 3) inject: 0 into: [:sum :x | sum + x]   // => 6
  /// ```
  inject: initial into: block: Block => @primitive "inject:into:"

  /// Return the first `n` elements.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 3, 4) take: 2          // => #(1, 2)
  /// ```
  take: n: Integer -> List => @primitive "take:"

  /// Return all elements after the first `n`.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 3, 4) drop: 2          // => #(3, 4)
  /// ```
  drop: n: Integer -> List => @primitive "drop:"

  /// Flatten one level of nested lists.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(#(1, 2), #(3, 4)) flatten    // => #(1, 2, 3, 4)
  /// ```
  flatten -> List => @primitive "flatten"

  /// Map each element with `block` then flatten one level.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2) flatMap: [:x | #(x, x * 10)]   // => #(1, 10, 2, 20)
  /// ```
  flatMap: block: Block -> List => @primitive "flatMap:"

  /// Count elements for which `block` returns true.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 3, 4) count: [:x | x > 2]      // => 2
  /// ```
  count: block: Block -> Integer => @primitive "count:"

  /// Test if any element satisfies `block`.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 3) anySatisfy: [:x | x > 2]    // => true
  /// ```
  anySatisfy: block: Block -> Boolean => @primitive "anySatisfy:"

  /// Test if all elements satisfy `block`.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(2, 4, 6) allSatisfy: [:x | x isEven] // => true
  /// ```
  allSatisfy: block: Block -> Boolean => @primitive "allSatisfy:"

  /// Concatenate two lists.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2) ++ #(3, 4)              // => #(1, 2, 3, 4)
  /// ```
  ++ other: List -> List => @primitive "++"

  /// Return a developer-readable string representation.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 3) printString           // => "#(1, 2, 3)"
  /// ```
  printString -> String => @primitive "printString"

  /// Return a subsequence from `start` to `end` (1-based, inclusive).
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(10, 20, 30, 40) from: 2 to: 3 // => #(20, 30)
  /// ```
  from: start: Integer to: end: Integer -> List => @primitive "from:to:"

  /// Return the 1-based index of the first occurrence, or `nil` if not found.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(10, 20, 30) indexOf: 20        // => 2
  /// #(10, 20, 30) indexOf: 99        // => nil
  /// ```
  indexOf: item -> Integer | Nil =>
    self inject: 0 into: [:each :i |
      newI := i + 1.
      each =:= item ifTrue: [^newI].
      newI
    ].
    nil

  /// Iterate with both element and 1-based index.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #("a", "b") eachWithIndex: [:item :i | Transcript show: i]
  /// ```
  eachWithIndex: block: Block -> Nil =>
    self inject: 0 into: [:each :i |
      newI := i + 1.
      block value: each value: newI.
      newI
    ].
    nil

  /// Combine two lists element-wise into a list of pairs.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2) zip: #("a", "b")        // => #(#(1, "a"), #(2, "b"))
  /// ```
  zip: other: List -> List => @primitive "zip:"

  /// Group elements by the result of `block` into a Dictionary.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 3, 4) groupBy: [:x | x isEven]
  /// ```
  groupBy: block: Block -> Dictionary => @primitive "groupBy:"

  /// Partition elements into two lists: those matching `block` and those not.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 3, 4) partition: [:x | x isEven]
  /// ```
  partition: block: Block -> List => @primitive "partition:"

  /// Take elements from the front while `block` returns true.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 3, 4) takeWhile: [:x | x < 3]    // => #(1, 2)
  /// ```
  takeWhile: block: Block -> List => @primitive "takeWhile:"

  /// Drop elements from the front while `block` returns true.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 3, 4) dropWhile: [:x | x < 3]    // => #(3, 4)
  /// ```
  dropWhile: block: Block -> List => @primitive "dropWhile:"

  /// Insert `separator` between each pair of elements.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2, 3) intersperse: 0        // => #(1, 0, 2, 0, 3)
  /// ```
  intersperse: separator -> List => @primitive "intersperse:"

  /// Prepend an item to the front of the list in O(1) time (returns a new list).
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(2, 3) addFirst: 1              // => #(1, 2, 3)
  /// #() addFirst: "x"               // => #("x")
  /// ```
  addFirst: item -> List => @primitive "addFirst:"

  /// Append an item to the end of the list (returns a new list).
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(1, 2) add: 3                   // => #(1, 2, 3)
  /// ```
  add: item -> List => @primitive "add:"

  /// Return a lazy Stream over the list elements.
  ///
  /// ## Examples
  /// ```beamtalk
  /// (#(1, 2, 3) stream) asList       // => #(1, 2, 3)
  /// ```
  stream -> Stream => @primitive "stream"

  /// Return a random element from the list.
  ///
  /// ## Examples
  /// ```beamtalk
  /// #(10, 20, 30) atRandom           // => one of 10, 20, 30
  /// ```
  atRandom => @primitive "atRandom"

  /// Create a List from a list (identity — a list is already a List).
  ///
  /// Used by the species pattern on Collection so that `collect:` and
  /// `select:` on a List return a List.
  ///
  /// ## Examples
  /// ```beamtalk
  /// List class withAll: #(1, 2, 3)   // => #(1, 2, 3)
  /// ```
  class withAll: list: List -> List => @primitive "withAll:"


