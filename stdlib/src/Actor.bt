// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

/// Actor — Base class for process-based objects.
///
/// Actor inherits from Object and adds process-based concurrency.
/// Every actor runs in its own BEAM process and communicates via
/// asynchronous messages. Use `spawn` instead of `new` to create actors.
///
/// ## Examples
/// ```beamtalk
/// Actor subclass: Counter
///   state: count = 0
///   increment => self.count := self.count + 1
///   count => self.count
/// ```
Object subclass: Actor
  /// Spawn a new actor process with default state.
  ///
  /// ## Examples
  /// ```beamtalk
  /// c := Counter spawn
  /// ```
  sealed spawn => @intrinsic actorSpawn

  /// Spawn a new actor process with initialization arguments.
  ///
  /// ## Examples
  /// ```beamtalk
  /// c := Counter spawnWith: #{#count => 10}
  /// ```
  sealed spawnWith: initArgs => @intrinsic actorSpawnWith

  /// Raises an error — actors must use `spawn`, not `new`.
  ///
  /// ## Examples
  /// ```beamtalk
  /// Counter new   // => ERROR: instantiation_error
  /// ```
  sealed new => self error: "Actors must use spawn, not new"

  /// Raises an error — actors must use `spawnWith:`, not `new:`.
  ///
  /// ## Examples
  /// ```beamtalk
  /// Counter new: #{}   // => ERROR: instantiation_error
  /// ```
  sealed new: _initArgs => self error: "Actors must use spawnWith:, not new:"

  /// Gracefully stop this actor (gen_server:stop).
  ///
  /// Idempotent: stopping an already-stopped actor succeeds silently.
  /// Raises an error if the actor times out during shutdown.
  ///
  /// ## Examples
  /// ```beamtalk
  /// counter stop   // => ok
  /// ```
  sealed stop => @primitive "actorStop"

  /// Forcefully kill this actor (exit(Pid, kill)).
  ///
  /// Unlike `stop`, kill cannot be trapped by the actor process.
  ///
  /// ## Examples
  /// ```beamtalk
  /// counter kill   // => ok
  /// ```
  sealed kill => @primitive "actorKill"

  /// Check if this actor's process is still alive.
  ///
  /// WARNING: isAlive check-then-act is inherently racy. The actor could die
  /// between the isAlive check and a subsequent message send. Use monitors
  /// for robust lifecycle management.
  ///
  /// ## Examples
  /// ```beamtalk
  /// counter isAlive   // => true or false
  /// ```
  sealed isAlive -> Boolean => @primitive "actorIsAlive"


