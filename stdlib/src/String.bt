// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

/// String â€” UTF-8 text operations.
///
/// Strings in Beamtalk are UTF-8 encoded binaries (Erlang binaries).
/// All string operations are grapheme-aware.
///
/// ## BEAM Mapping
/// Beamtalk strings map directly to Erlang binaries.
///
/// ## Examples
/// ```beamtalk
/// "hello" class         // => String
/// "hello" length        // => 5
/// "hello" ++ " world"   // => "hello world"
/// ```
sealed typed Collection subclass: String
  /// Test strict equality with another string.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "abc" =:= "abc"      // => true
  /// "abc" =:= "xyz"      // => false
  /// ```
  =:= other -> Boolean => @primitive "=:="

  /// Test inequality with another string.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "abc" /= "xyz"     // => true
  /// "abc" /= "abc"     // => false
  /// ```
  /= other -> Boolean => @primitive "/="

  /// Test if the receiver sorts before another string.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "abc" < "xyz"      // => true
  /// "xyz" < "abc"      // => false
  /// ```
  < other -> Boolean => @primitive "<"

  /// Test if the receiver sorts after another string.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "xyz" > "abc"      // => true
  /// "abc" > "xyz"      // => false
  /// ```
  > other -> Boolean => @primitive ">"

  /// Test if the receiver sorts before or equal to another string.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "abc" <= "xyz"     // => true
  /// "abc" <= "abc"     // => true
  /// ```
  <= other -> Boolean => @primitive "<="

  /// Test if the receiver sorts after or equal to another string.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "xyz" >= "abc"     // => true
  /// "abc" >= "abc"     // => true
  /// ```
  >= other -> Boolean => @primitive ">="

  /// Concatenate the receiver with another string.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "hello" ++ " world"  // => "hello world"
  /// "a" ++ "b"           // => "ab"
  /// ```
  ++ other: String -> String => @primitive "++"

  /// Number of grapheme clusters in the string.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "hello" length       // => 5
  /// "" length            // => 0
  /// ```
  length -> Integer => @primitive "length"

  /// Alias for `length`.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "hello" size         // => 5
  /// ```
  size -> Integer => self length

  /// Return the grapheme cluster at the given 1-based index.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "hello" at: 1        // => "h"
  /// "hello" at: 5        // => "o"
  /// ```
  at: index: Integer -> String => @primitive "at:"

  /// Convert all characters to uppercase.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "hello" uppercase    // => "HELLO"
  /// ```
  uppercase -> String => @primitive "uppercase"

  /// Convert all characters to lowercase.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "HELLO" lowercase    // => "hello"
  /// ```
  lowercase -> String => @primitive "lowercase"

  /// Capitalize the first character.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "hello" capitalize   // => "Hello"
  /// ```
  capitalize -> String => @primitive "capitalize"

  /// Remove leading and trailing whitespace.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "  hello  " trim     // => "hello"
  /// ```
  trim -> String => @primitive "trim"

  /// Remove leading whitespace.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "  hello" trimLeft   // => "hello"
  /// ```
  trimLeft -> String => @primitive "trimLeft"

  /// Remove trailing whitespace.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "hello  " trimRight  // => "hello"
  /// ```
  trimRight -> String => @primitive "trimRight"

  /// Reverse the string (grapheme-aware).
  ///
  /// ## Examples
  /// ```beamtalk
  /// "hello" reverse      // => "olleh"
  /// ```
  reverse -> String => @primitive "reverse"

  /// Test if the receiver contains a substring.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "hello world" includesSubstring: "world"  // => true
  /// "hello" includesSubstring: "xyz"          // => false
  /// ```
  includesSubstring: substring: String -> Boolean => @primitive "includes:"

  /// Test if the receiver starts with the given prefix.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "hello" startsWith: "hel"   // => true
  /// "hello" startsWith: "xyz"   // => false
  /// ```
  startsWith: prefix: String -> Boolean => @primitive "startsWith:"

  /// Test if the receiver ends with the given suffix.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "hello" endsWith: "llo"     // => true
  /// "hello" endsWith: "xyz"     // => false
  /// ```
  endsWith: suffix: String -> Boolean => @primitive "endsWith:"

  /// Return the 1-based index of the first occurrence of a substring, or `nil` if not found.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "hello" indexOf: "ell"      // => 2
  /// "hello" indexOf: "xyz"      // => nil
  /// ```
  indexOf: substring: String -> Integer | Nil => @primitive "indexOf:"

  /// Split the string by a separator.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "a,b,c" split: ","          // => #("a", "b", "c")
  /// ```
  split: separator: String -> List => @primitive "split:"

  /// Split the string by a pattern.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "a::b::c" splitOn: "::"     // => #("a", "b", "c")
  /// ```
  splitOn: pattern: String -> List => @primitive "splitOn:"

  /// Repeat the string `n` times.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "ab" repeat: 3              // => "ababab"
  /// ```
  repeat: n: Integer -> String => @primitive "repeat:"

  /// Split the string into lines.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "a\nb\nc" lines             // => #("a", "b", "c")
  /// ```
  lines -> List => @primitive "lines"

  /// Split the string into words (whitespace-separated).
  ///
  /// ## Examples
  /// ```beamtalk
  /// "hello world" words         // => #("hello", "world")
  /// ```
  words -> List => @primitive "words"

  /// Replace all occurrences of `old` with `new`.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "aabaa" replaceAll: "a" with: "x"     // => "xxbxx"
  /// ```
  replaceAll: old: String with: new: String -> String => @primitive "replaceAll:with:"

  /// Replace the first occurrence of `old` with `new`.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "aabaa" replaceFirst: "a" with: "x"   // => "xabaa"
  /// ```
  replaceFirst: old: String with: new: String -> String => @primitive "replaceFirst:with:"

  /// Take the first `n` grapheme clusters.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "hello" take: 3             // => "hel"
  /// ```
  take: n: Integer -> String => @primitive "take:"

  /// Drop the first `n` grapheme clusters.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "hello" drop: 2             // => "llo"
  /// ```
  drop: n: Integer -> String => @primitive "drop:"

  /// Left-pad the string to the given width with spaces.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "hi" padLeft: 5             // => "   hi"
  /// ```
  padLeft: width: Integer -> String => @primitive "padLeft:"

  /// Right-pad the string to the given width with spaces.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "hi" padRight: 5            // => "hi   "
  /// ```
  padRight: width: Integer -> String => @primitive "padRight:"

  /// Left-pad the string to the given width with the specified character.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "hi" padLeft: 5 with: "0"  // => "000hi"
  /// ```
  padLeft: width: Integer with: char: String -> String => @primitive "padLeft:with:"

  /// Right-pad the string to the given width with the specified character.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "hi" padRight: 5 with: "0"  // => "hi000"
  /// ```
  padRight: width: Integer with: char: String -> String => @primitive "padRight:with:"

  /// Test if the string is empty.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "" isEmpty                  // => true
  /// "hello" isEmpty             // => false
  /// ```
  isEmpty -> Boolean => self length =:= 0

  /// Test if the string is not empty.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "hello" isNotEmpty          // => true
  /// "" isNotEmpty               // => false
  /// ```
  isNotEmpty -> Boolean => self length > 0

  /// Test if the string is empty or contains only whitespace.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "   " isBlank               // => true
  /// "" isBlank                  // => true
  /// ```
  isBlank -> Boolean => @primitive "isBlank"

  /// Test if all characters are digits.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "123" isDigit               // => true
  /// "12a" isDigit               // => false
  /// ```
  isDigit -> Boolean => @primitive "isDigit"

  /// Test if all characters are letters.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "abc" isAlpha               // => true
  /// "ab1" isAlpha               // => false
  /// ```
  isAlpha -> Boolean => @primitive "isAlpha"

  /// Parse the string as an integer.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "42" asInteger              // => 42
  /// ```
  asInteger -> Integer => @primitive "asInteger"

  /// Parse the string as a float.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "3.14" asFloat              // => 3.14
  /// ```
  asFloat -> Float => @primitive "asFloat"

  /// Convert the string to an atom (Symbol).
  ///
  /// ## Examples
  /// ```beamtalk
  /// "hello" asAtom              // => #hello
  /// ```
  asAtom -> Symbol => @primitive "asAtom"

  /// Convert the string to a list of grapheme cluster strings.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "abc" asList                // => #("a", "b", "c")
  /// ```
  asList -> List => @primitive "asList"

  /// Iterate over each grapheme cluster, evaluating `block` with each one.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "abc" do: [:c | Transcript show: c]
  /// ```
  do: block: Block -> Nil => @primitive "each:"

  /// Collect results of evaluating `block` on each grapheme cluster.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "abc" collect: [:c | c uppercase]  // => #("A", "B", "C")
  /// ```
  collect: block: Block -> List => @primitive "collect:"

  /// Select grapheme clusters for which `block` returns true.
  ///
  /// Returns a String of the matching grapheme clusters (filtered graphemes
  /// remain valid graphemes).
  ///
  /// ## Examples
  /// ```beamtalk
  /// "a1b2" select: [:c | c isAlpha]    // => "ab"
  /// ```
  select: block: Block -> String => @primitive "select:"

  /// Return a lazy Stream over the characters (grapheme clusters).
  ///
  /// ## Examples
  /// ```beamtalk
  /// ("hello" stream) take: 3         // => #("h", "e", "l")
  /// ```
  stream -> Stream => @primitive "stream"

  /// Test if the string matches a regular expression pattern.
  /// Accepts a String pattern or compiled Regex object.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "hello123" matchesRegex: "[0-9]+"          // => true
  /// "hello" matchesRegex: "^[0-9]+$"           // => false
  /// ```
  matchesRegex: pattern -> Boolean => @primitive "matchesRegex:"

  /// Test if the string matches a pattern with PCRE options.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "Hello" matchesRegex: "[a-z]+" options: #(#caseless)  // => true
  /// ```
  matchesRegex: pattern options: opts: List -> Boolean => @primitive "matchesRegex:options:"

  /// Find the first regex match, returning matched String or nil.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "hello123world" firstMatch: "[0-9]+"       // => "123"
  /// "hello" firstMatch: "[0-9]+"               // => nil
  /// ```
  firstMatch: pattern -> String | Nil => @primitive "firstMatch:"

  /// Find all regex matches, returning a List of Strings.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "a1b2c3" allMatches: "[0-9]+"              // => #("1", "2", "3")
  /// ```
  allMatches: pattern -> List => @primitive "allMatches:"

  /// Replace the first regex match with a replacement string.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "hello world" replaceRegex: "[aeiou]" with: "*"      // => "h*llo world"
  /// ```
  replaceRegex: pattern with: replacement: String -> String => @primitive "replaceRegex:with:"

  /// Replace all regex matches with a replacement string.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "hello world" replaceAllRegex: "[aeiou]" with: "*"   // => "h*ll* w*rld"
  /// ```
  replaceAllRegex: pattern with: replacement: String -> String => @primitive "replaceAllRegex:with:"

  /// Split the string by a regex pattern.
  ///
  /// ## Examples
  /// ```beamtalk
  /// "a,,b,,,c" splitRegex: ",+"                // => #("a", "b", "c")
  /// ```
  splitRegex: pattern -> List => @primitive "splitRegex:"

  /// Return a developer-readable string representation (with surrounding quotes).
  /// Embedded double-quote characters are doubled (Beamtalk string literal convention).
  ///
  /// ## Examples
  /// ```beamtalk
  /// "hello" printString         // => """hello"""
  /// ```
  printString -> String => """" ++ (self replaceAll: """" with: """""") ++ """"

  /// Return the string itself for user-facing display (no surrounding quotes).
  ///
  /// ## Examples
  /// ```beamtalk
  /// "hello" displayString       // => "hello"
  /// ```
  displayString -> String => self

  /// Create a String by joining a list of grapheme cluster strings.
  ///
  /// Useful for constructing a String from the result of `asList` or
  /// `select:` operations. Each element should be a grapheme string.
  ///
  /// ## Examples
  /// ```beamtalk
  /// String class withAll: #("h", "e", "l", "l", "o")  // => "hello"
  /// ```
  class withAll: list: List -> String => @primitive "withAll:"
