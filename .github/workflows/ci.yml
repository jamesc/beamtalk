# Copyright 2026 James Casey
# SPDX-License-Identifier: Apache-2.0

name: CI

on:
  push:
    branches: [main]
    paths-ignore:
      - '*.md'
      - 'docs/**'
      - 'LICENSE'
      - 'SECURITY.md'
      - '.github/skills/**'
      - '.devcontainer/**'
  pull_request:
    branches: [main]
    paths-ignore:
      - '*.md'
      - 'docs/**'
      - 'LICENSE'
      - 'SECURITY.md'
      - '.github/skills/**'
      - '.devcontainer/**'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

env:
  CARGO_TERM_COLOR: always

jobs:
  # ‚îÄ‚îÄ‚îÄ Fast checks on all platforms ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  check:
    strategy:
      fail-fast: false
      matrix:
        # Pin Windows to 2022: erlef/setup-beam@v1 doesn't support win25 (windows-2025) yet
        os: [ubuntu-latest, windows-2022]
    runs-on: ${{ matrix.os }}
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v6

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy, rustfmt

      - name: Install Erlang/OTP
        uses: erlef/setup-beam@v1
        with:
          otp-version: '27.0'
          rebar3-version: '3.23'

      - name: Install Just
        uses: extractions/setup-just@v3

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: editors/vscode/package-lock.json

      - name: Cache cargo registry
        uses: actions/cache@v5
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Cache Erlang/rebar3 artifacts
        uses: actions/cache@v5
        with:
          path: |
            ~/.cache/rebar3
            runtime/_build
            ~/.rebar3
          key: ${{ runner.os }}-erlang-${{ hashFiles('runtime/rebar.config', 'runtime/apps/beamtalk_runtime/src/**', 'runtime/apps/beamtalk_runtime/include/**') }}-otp-27.0-rebar3-3.23
          restore-keys: |
            ${{ runner.os }}-erlang-${{ hashFiles('runtime/rebar.config') }}-otp-27.0-rebar3-3.23
            ${{ runner.os }}-erlang-otp-27.0-

      - name: Build, lint, and fast tests
        run: just clippy fmt-check build test

  # ‚îÄ‚îÄ‚îÄ Full test suite on Linux only (requires Erlang/OTP) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  test:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Install Erlang/OTP
        uses: erlef/setup-beam@v1
        with:
          otp-version: '27.0'
          rebar3-version: '3.23'

      - name: Install Just
        uses: extractions/setup-just@v3

      - name: Cache Erlang/rebar3 artifacts
        uses: actions/cache@v5
        with:
          path: |
            ~/.cache/rebar3
            runtime/_build
            ~/.rebar3
          key: ${{ runner.os }}-erlang-${{ hashFiles('runtime/rebar.config', 'runtime/apps/beamtalk_runtime/src/**', 'runtime/apps/beamtalk_runtime/include/**') }}-otp-27.0-rebar3-3.23
          restore-keys: |
            ${{ runner.os }}-erlang-${{ hashFiles('runtime/rebar.config') }}-otp-27.0-rebar3-3.23
            ${{ runner.os }}-erlang-otp-27.0-

      - name: Cache Dialyzer PLT
        uses: actions/cache@v5
        with:
          path: |
            runtime/_build/default/*_plt
          key: ${{ runner.os }}-dialyzer-${{ hashFiles('runtime/rebar.config') }}-otp-27.0-rebar3-3.23
          restore-keys: |
            ${{ runner.os }}-dialyzer-otp-27.0-

      - name: Cache cargo registry
        uses: actions/cache@v5
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Build Rust
        run: just build-rust

      - name: Build Erlang runtime
        run: just build-erlang

      - name: Build standard library
        run: just build-stdlib

      - name: Check for Erlang changes
        id: erlang-changes
        run: |
          if [ "${{ github.event_name }}" = "push" ]; then
            # On push to main, compare with previous commit
            BASE="${{ github.event.before }}"
          else
            # On PR, compare with the merge base against main
            BASE="origin/main"
          fi
          if git diff --name-only "$BASE"...HEAD | grep -qE '^runtime/'; then
            echo "changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "changed=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Test Rust (unit + integration)
        run: just test-rust

      - name: Test stdlib (compiled language features)
        run: just test-stdlib

      - name: Test Erlang runtime (unit tests)
        run: just test-runtime

      - name: Dialyzer type checking (Erlang runtime)
        if: steps.erlang-changes.outputs.changed == 'true'
        run: just dialyzer

      - name: Test workspace integration
        run: just test-integration

      - name: Test MCP server integration
        run: just test-mcp

      - name: Test E2E (full pipeline)
        run: just test-e2e

  coverage:
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    timeout-minutes: 25
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v6

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: llvm-tools-preview

      - name: Install Erlang/OTP
        uses: erlef/setup-beam@v1
        with:
          otp-version: '27.0'
          rebar3-version: '3.23'

      - name: Install Just
        uses: extractions/setup-just@v3

      - name: Cache Erlang/rebar3 artifacts
        uses: actions/cache@v5
        with:
          path: |
            ~/.cache/rebar3
            runtime/_build
            ~/.rebar3
          key: ${{ runner.os }}-erlang-${{ hashFiles('runtime/rebar.config', 'runtime/apps/beamtalk_runtime/src/**', 'runtime/apps/beamtalk_runtime/include/**') }}-otp-27.0-rebar3-3.23
          restore-keys: |
            ${{ runner.os }}-erlang-${{ hashFiles('runtime/rebar.config') }}-otp-27.0-rebar3-3.23
            ${{ runner.os }}-erlang-otp-27.0-

      - name: Cache cargo registry
        uses: actions/cache@v5
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-coverage-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-coverage-
            ${{ runner.os }}-cargo-

      - name: Install cargo-llvm-cov
        uses: taiki-e/install-action@cargo-llvm-cov

      - name: Generate Rust coverage (Cobertura format for action)
        run: |
          # Generate Cobertura format (for CodeCoverageSummary action)
          cargo llvm-cov --all-targets --workspace --cobertura --output-path coverage.cobertura.xml

      - name: Build Erlang runtime
        run: just build-erlang

      - name: Build standard library
        run: just build-stdlib

      - name: Generate Erlang coverage (unit + E2E + stdlib)
        run: just coverage-all

      - name: Rust Coverage Summary
        id: rust_coverage
        continue-on-error: true
        uses: irongut/CodeCoverageSummary@v1.3.0
        with:
          filename: coverage.cobertura.xml
          badge: true
          format: markdown
          output: both
          hide_complexity: true

      - name: Preserve Rust Coverage Report
        run: |
          # Rename Rust coverage report before Erlang step overwrites it
          if [ -f code-coverage-results.md ]; then
            mv code-coverage-results.md rust-coverage-results.md
          fi

      - name: Erlang Coverage Summary
        id: erlang_coverage
        continue-on-error: true
        uses: irongut/CodeCoverageSummary@v1.3.0
        with:
          filename: 'runtime/_build/test/covertool/beamtalk_runtime.covertool.xml,runtime/_build/test/covertool/beamtalk_workspace.covertool.xml'
          badge: true
          format: markdown
          output: both
          hide_branch_rate: false
          hide_complexity: true
          indicators: true
          thresholds: '60 70'

      - name: Preserve Erlang Runtime Coverage Report
        run: |
          # Rename Erlang coverage report for clarity
          if [ -f code-coverage-results.md ]; then
            mv code-coverage-results.md erlang-coverage-results.md
          fi

      - name: Upload Coverage Reports
        uses: actions/upload-artifact@v6
        with:
          name: coverage-reports
          path: |
            rust-coverage-results.md
            erlang-coverage-results.md
            runtime/_build/test/cover/index.html
            runtime/_build/test/cover/aggregate/*.html
            coverage.cobertura.xml
            runtime/_build/test/covertool/*.xml
          retention-days: 30

      - name: Add Coverage to Job Summary
        run: |
          echo "## üìä Code Coverage Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Rust Coverage" >> $GITHUB_STEP_SUMMARY
          if [ -f rust-coverage-results.md ]; then
            cat rust-coverage-results.md >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "![Coverage](${{ steps.rust_coverage.outputs.badge }})" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ö†Ô∏è WARNING: Rust coverage report not generated" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Erlang Coverage" >> $GITHUB_STEP_SUMMARY
          if [ -f erlang-coverage-results.md ]; then
            cat erlang-coverage-results.md >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "![Coverage](${{ steps.erlang_coverage.outputs.badge }})" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ö†Ô∏è WARNING: Erlang coverage report not generated" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üìÅ **Detailed HTML Reports:** Download the \`coverage-reports\` artifact for per-module breakdowns" >> $GITHUB_STEP_SUMMARY

      - name: Check Coverage Thresholds
        id: rust_thresholds
        continue-on-error: true
        run: |
          # Extract Rust line coverage percentage from CodeCoverageSummary output
          # The action outputs to rust-coverage-results.md (markdown format)
          if [ ! -f rust-coverage-results.md ]; then
            echo "‚ö†Ô∏è WARNING: rust-coverage-results.md not found, skipping threshold check"
            exit 0
          fi
          
          # Extract coverage percentages from markdown format
          # Markdown format: **Summary** | **83%** (1212 / 1460) | **69%** (262 / 378) | 682 | ‚úî
          # Match both integer (83%) and decimal (83.47%) percentages
          rust_coverage=$(grep -E 'Summary.*\|.*%' rust-coverage-results.md | grep -oE '\*\*[0-9]+(\.[0-9]+)?%\*\*' | head -1 | grep -oE '[0-9]+(\.[0-9]+)?' || echo "0")
          rust_branch=$(grep -E 'Summary.*\|.*%' rust-coverage-results.md | grep -oE '\*\*[0-9]+(\.[0-9]+)?%\*\*' | tail -1 | grep -oE '[0-9]+(\.[0-9]+)?' || echo "0")
          
          echo "Rust Line Coverage: ${rust_coverage}%"
          echo "Rust Branch Coverage: ${rust_branch}%"
          echo "rust_coverage=${rust_coverage}" >> "$GITHUB_OUTPUT"
          
          # Check thresholds using awk for portability (no bc dependency)
          line_check=$(awk -v cov="$rust_coverage" 'BEGIN { if (cov < 70.0) print "FAIL"; else print "PASS" }')
          branch_check=$(awk -v cov="$rust_branch" 'BEGIN { if (cov < 80.0) print "WARN"; else print "PASS" }')
          
          if [ "$line_check" = "FAIL" ]; then
            echo "‚ùå FAILURE: Rust line coverage ${rust_coverage}% is below 70% threshold"
            exit 1
          fi
          
          if [ "$branch_check" = "WARN" ]; then
            echo "‚ö†Ô∏è WARNING: Rust branch coverage ${rust_branch}% is below 80% threshold"
            echo "This will become a failure in future releases"
          fi
          
          echo "‚úÖ Coverage thresholds met"

      - name: Check Erlang Coverage Thresholds
        id: erlang_thresholds
        continue-on-error: true
        run: |
          if [ ! -f erlang-coverage-results.md ]; then
            echo "‚ö†Ô∏è WARNING: erlang-coverage-results.md not found, skipping threshold check"
            exit 0
          fi
          
          erlang_coverage=$(grep -E 'Summary.*\|.*%' erlang-coverage-results.md | grep -oE '\*\*[0-9]+(\.[0-9]+)?%\*\*' | head -1 | grep -oE '[0-9]+(\.[0-9]+)?' || echo "0")
          erlang_branch=$(grep -E 'Summary.*\|.*%' erlang-coverage-results.md | grep -oE '\*\*[0-9]+(\.[0-9]+)?%\*\*' | tail -1 | grep -oE '[0-9]+(\.[0-9]+)?' || echo "0")
          
          echo "Erlang Line Coverage: ${erlang_coverage}%"
          echo "Erlang Branch Coverage: ${erlang_branch}%"
          echo "erlang_coverage=${erlang_coverage}" >> "$GITHUB_OUTPUT"
          
          line_check=$(awk -v cov="$erlang_coverage" 'BEGIN { if (cov < 50.0) print "FAIL"; else print "PASS" }')
          branch_check=$(awk -v cov="$erlang_branch" 'BEGIN { if (cov < 60.0) print "WARN"; else print "PASS" }')
          
          if [ "$line_check" = "FAIL" ]; then
            echo "‚ùå FAILURE: Erlang line coverage ${erlang_coverage}% is below 50% threshold"
            exit 1
          fi
          
          if [ "$branch_check" = "WARN" ]; then
            echo "‚ö†Ô∏è WARNING: Erlang branch coverage ${erlang_branch}% is below 60% threshold"
            echo "This will become a failure in future releases"
          fi
          
          echo "‚úÖ Erlang coverage thresholds met"

      - name: Publish coverage badges
        run: |
          # Determine badge colors based on coverage percentage
          badge_color() {
            local cov=$1
            awk -v c="$cov" 'BEGIN {
              if (c >= 80) print "brightgreen"
              else if (c >= 70) print "green"
              else if (c >= 60) print "yellowgreen"
              else if (c >= 50) print "yellow"
              else print "red"
            }'
          }

          RUST_COV="${{ steps.rust_thresholds.outputs.rust_coverage }}"
          ERLANG_COV="${{ steps.erlang_thresholds.outputs.erlang_coverage }}"

          # Guard against missing or non-numeric coverage values
          RUST_MSG="unknown"
          RUST_COLOR="lightgrey"
          ERLANG_MSG="unknown"
          ERLANG_COLOR="lightgrey"

          if echo "$RUST_COV" | grep -Eq '^[0-9]+([.][0-9]+)?$'; then
            RUST_MSG="${RUST_COV}%"
            RUST_COLOR=$(badge_color "$RUST_COV")
          fi

          if echo "$ERLANG_COV" | grep -Eq '^[0-9]+([.][0-9]+)?$'; then
            ERLANG_MSG="${ERLANG_COV}%"
            ERLANG_COLOR=$(badge_color "$ERLANG_COV")
          fi

          # Create badge JSON files (shields.io endpoint format)
          mkdir -p badges
          echo "{\"schemaVersion\":1,\"label\":\"Rust coverage\",\"message\":\"${RUST_MSG}\",\"color\":\"${RUST_COLOR}\"}" > badges/rust-coverage.json
          echo "{\"schemaVersion\":1,\"label\":\"Erlang coverage\",\"message\":\"${ERLANG_MSG}\",\"color\":\"${ERLANG_COLOR}\"}" > badges/erlang-coverage.json

          # Commit to badges branch
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git checkout --orphan badges-tmp
          git rm -rf . > /dev/null 2>&1 || true
          cp -r badges/* .
          rm -rf badges
          git add rust-coverage.json erlang-coverage.json
          git commit -m "Update coverage badges [skip ci]"
          git push origin HEAD:badges --force

      - name: Fail if coverage thresholds not met
        if: steps.rust_thresholds.outcome == 'failure' || steps.erlang_thresholds.outcome == 'failure'
        run: |
          echo "‚ùå Coverage thresholds not met (see above for details)"
          exit 1
