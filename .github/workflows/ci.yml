# Copyright 2026 James Casey
# SPDX-License-Identifier: Apache-2.0

name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

permissions:
  contents: read
  pull-requests: write

env:
  CARGO_TERM_COLOR: always

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy, rustfmt

      - name: Install Erlang/OTP
        uses: erlef/setup-beam@v1
        with:
          otp-version: '27.0'
          rebar3-version: '3.23'

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Build
        run: cargo build --all-targets

      - name: Clippy
        run: cargo clippy --all-targets -- -D warnings

      - name: Format check
        run: cargo fmt --all -- --check

      - name: Test
        run: cargo test --all-targets -- --skip erlang_runtime_unit_tests

      - name: Test Erlang runtime (unit tests)
        run: |
          cd runtime
          # rebar3 eunit exits with 1 if tests are skipped, check actual failures
          set +e  # Don't exit on error
          OUTPUT=$(rebar3 eunit 2>&1)
          EXIT_CODE=$?
          echo "$OUTPUT"
          
          # Check if any tests actually failed (Failed: N where N > 0)
          if echo "$OUTPUT" | grep -q "Failed: [1-9]"; then
            echo "Tests failed!"
            exit 1
          fi
          
          # All tests passed (even if some skipped), success
          exit 0

      - name: Test Erlang runtime (integration tests)
        run: |
          # Start compiler daemon in background
          ./target/debug/beamtalk daemon start --foreground &
          DAEMON_PID=$!
          
          # Ensure cleanup happens even if tests fail
          cleanup() {
            kill $DAEMON_PID 2>/dev/null || true
          }
          trap cleanup EXIT
          
          # Wait for daemon to initialize and verify it stays alive
          # Poll for up to 10 seconds to ensure daemon is ready
          echo "Waiting for daemon to initialize..."
          for i in $(seq 1 10); do
            if ! kill -0 "$DAEMON_PID" 2>/dev/null; then
              echo "Daemon process exited before integration tests could run"
              exit 1
            fi
            # Check if socket is ready (daemon creates ~/.beamtalk/daemon.sock)
            if [ -S "$HOME/.beamtalk/daemon.sock" ]; then
              echo "Daemon is ready (socket exists)"
              break
            fi
            sleep 1
          done
          
          # Final verification that daemon is still running
          if ! kill -0 "$DAEMON_PID" 2>/dev/null; then
            echo "Compiler daemon failed to start or exited prematurely"
            exit 1
          fi
          
          # Run integration tests
          cd runtime
          rebar3 eunit --module=beamtalk_repl_integration_tests

  coverage:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: llvm-tools-preview

      - name: Install Erlang/OTP
        uses: erlef/setup-beam@v1
        with:
          otp-version: '27.0'
          rebar3-version: '3.23'

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-coverage-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-coverage-
            ${{ runner.os }}-cargo-

      - name: Install cargo-llvm-cov
        uses: taiki-e/install-action@cargo-llvm-cov

      - name: Generate Rust coverage
        run: |
          # Generate Cobertura format (for CodeCoverageSummary action)
          cargo llvm-cov --all-targets --workspace --cobertura --output-path coverage.cobertura.xml \
            -- --skip commands::build::tests::test_build_single_file \
               --skip commands::build::tests::test_build_multiple_files \
               --skip commands::run::tests::test_run_calls_build \
               --skip erlang_runtime_unit_tests

      - name: Generate Erlang coverage
        run: |
          cd runtime
          # Run eunit with coverage (exits with 1 if tests skipped, but that's ok)
          set +e  # Don't exit on error
          OUTPUT=$(rebar3 eunit --cover 2>&1)
          EXIT_CODE=$?
          echo "$OUTPUT"
          
          # Check if any tests actually failed (Failed: N where N > 0)
          if echo "$OUTPUT" | grep -q "Failed: [1-9]"; then
            echo "Tests failed!"
            exit 1
          fi
          
          # Tests passed, now generate coverage reports
          set -e  # Exit on error for coverage commands
          rebar3 cover --verbose
          rebar3 covertool generate

      - name: Rust Coverage Summary
        id: rust_coverage
        continue-on-error: true
        uses: irongut/CodeCoverageSummary@v1.3.0
        with:
          filename: coverage.cobertura.xml
          badge: true
          format: markdown
          output: both

      - name: Preserve Rust Coverage Report
        run: |
          # Rename Rust coverage report before Erlang step overwrites it
          if [ -f code-coverage-results.md ]; then
            mv code-coverage-results.md rust-coverage-results.md
          fi

      - name: Erlang Coverage Summary
        id: erlang_coverage
        continue-on-error: true
        uses: irongut/CodeCoverageSummary@v1.3.0
        with:
          filename: runtime/_build/test/covertool/beamtalk_runtime.covertool.xml
          badge: true
          format: markdown
          output: both

      - name: Preserve Erlang Coverage Report
        run: |
          # Rename Erlang coverage report for clarity
          if [ -f code-coverage-results.md ]; then
            mv code-coverage-results.md erlang-coverage-results.md
          fi

      - name: Add Coverage to Job Summary
        run: |
          echo "## üìä Code Coverage Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Rust Coverage" >> $GITHUB_STEP_SUMMARY
          if [ -f rust-coverage-results.md ]; then
            cat rust-coverage-results.md >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "![Coverage](${{ steps.rust_coverage.outputs.badge }})" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ö†Ô∏è WARNING: Rust coverage report not generated" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Erlang Coverage" >> $GITHUB_STEP_SUMMARY
          if [ -f erlang-coverage-results.md ]; then
            cat erlang-coverage-results.md >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "![Coverage](${{ steps.erlang_coverage.outputs.badge }})" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ö†Ô∏è WARNING: Erlang coverage report not generated" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Check Coverage Thresholds
        run: |
          # Extract Rust line coverage percentage from CodeCoverageSummary output
          # The action outputs to rust-coverage-results.md (markdown format)
          if [ ! -f rust-coverage-results.md ]; then
            echo "‚ö†Ô∏è WARNING: rust-coverage-results.md not found, skipping threshold check"
            exit 0
          fi
          
          # Extract coverage percentages from markdown format
          # Markdown format: **Summary** | **83%** (1212 / 1460) | **69%** (262 / 378) | 682 | ‚úî
          # Match both integer (83%) and decimal (83.47%) percentages
          rust_coverage=$(grep -E 'Summary.*\|.*%' rust-coverage-results.md | grep -oE '\*\*[0-9]+(\.[0-9]+)?%\*\*' | head -1 | grep -oE '[0-9]+(\.[0-9]+)?' || echo "0")
          rust_branch=$(grep -E 'Summary.*\|.*%' rust-coverage-results.md | grep -oE '\*\*[0-9]+(\.[0-9]+)?%\*\*' | tail -1 | grep -oE '[0-9]+(\.[0-9]+)?' || echo "0")
          
          echo "Rust Line Coverage: ${rust_coverage}%"
          echo "Rust Branch Coverage: ${rust_branch}%"
          
          # Check thresholds using awk for portability (no bc dependency)
          line_check=$(awk -v cov="$rust_coverage" 'BEGIN { if (cov < 70.0) print "FAIL"; else print "PASS" }')
          branch_check=$(awk -v cov="$rust_branch" 'BEGIN { if (cov < 80.0) print "WARN"; else print "PASS" }')
          
          if [ "$line_check" = "FAIL" ]; then
            echo "‚ùå FAILURE: Rust line coverage ${rust_coverage}% is below 70% threshold"
            exit 1
          fi
          
          if [ "$branch_check" = "WARN" ]; then
            echo "‚ö†Ô∏è WARNING: Rust branch coverage ${rust_branch}% is below 80% threshold"
            echo "This will become a failure in future releases"
          fi
          
          echo "‚úÖ Coverage thresholds met"

      - name: Prepare PR Comment
        if: github.event_name == 'pull_request'
        run: |
          # Get short commit hash
          COMMIT_HASH=$(echo "${{ github.event.pull_request.head.sha }}" | cut -c1-7)
          
          cat > pr-comment.md << EOF
          ## üìä Code Coverage Report (${COMMIT_HASH})
          
          ### Rust Coverage
          EOF
          if [ -f rust-coverage-results.md ]; then
            cat rust-coverage-results.md >> pr-comment.md
          else
            echo "‚ö†Ô∏è WARNING: Rust coverage report not generated" >> pr-comment.md
          fi
          echo "" >> pr-comment.md
          echo "### Erlang Coverage" >> pr-comment.md
          if [ -f erlang-coverage-results.md ]; then
            cat erlang-coverage-results.md >> pr-comment.md
          else
            echo "‚ö†Ô∏è WARNING: Erlang coverage report not generated" >> pr-comment.md
          fi

      - name: Add PR Comment
        if: github.event_name == 'pull_request'
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          recreate: true
          path: pr-comment.md
