%% Copyright 2026 James Casey
%% SPDX-License-Identifier: Apache-2.0

%%% @doc Unified message dispatch entry point.
%%%
%%% **DDD Context:** Runtime / Message Dispatch
%%%
%%% All non-intrinsic message sends are routed through this module,
%%% replacing the inline type-checking code previously generated by
%%% dispatch_codegen.rs (BT-223).
%%%
%%% ## Dispatch Strategy
%%%
%%% | Receiver Type | Dispatch Path | Returns |
%%% |---------------|---------------|---------|
%%% | Actor record  | `beamtalk_actor:sync_send/3` | Value |
%%% | Class object  | `beamtalk_object_class:class_send/3` | Value |
%%% | Primitive     | `beamtalk_primitive:send/3` | Value |
%%%
%%% ## Usage (from generated Core Erlang)
%%%
%%% ```erlang
%%% call 'beamtalk_message_dispatch':'send'(Receiver, 'selector', [Args])
%%% ```
%%%
%%% See: ADR 0006 (Unified Method Dispatch), BT-430, ADR 0043 (BT-918)

-module(beamtalk_message_dispatch).
-export([send/3, cast/3]).

-include("beamtalk.hrl").

%% Compiled stdlib modules are generated from Core Erlang.
%% Dialyzer can't resolve them if stdlib hasn't been built yet.
-dialyzer({nowarn_function, [send/3, cast/3]}).

%% @doc Send a message to any receiver (actor, class object, primitive, or future).
%%
%% For futures, auto-awaits the value and re-dispatches (BT-840).
%% For actors, sends synchronously via gen_server:call (BT-918 / ADR 0043).
%% For class objects, dispatches synchronously via class_send.
%% For primitives, dispatches synchronously via beamtalk_primitive:send/3.
-spec send(term(), atom(), list()) -> term().
send({beamtalk_future, _} = Future, Selector, Args) ->
    %% BT-840: Auto-await futures in chained message sends.
    %% This enables backward compat during migration — any residual futures
    %% returned by old code paths are awaited before re-dispatching.
    Value = beamtalk_future:await(Future),
    send(Value, Selector, Args);
send(Receiver, Selector, Args) ->
    case is_actor(Receiver) of
        true ->
            case element(2, Receiver) of
                'Metaclass' ->
                    %% ADR 0036 (BT-802): Metaclass objects dispatch synchronously via
                    %% the Metaclass → Class → Behaviour chain. They must NOT be treated
                    %% as regular actor instances.
                    beamtalk_primitive:send(Receiver, Selector, Args);
                _ ->
                    case beamtalk_class_registry:is_class_object(Receiver) of
                        true ->
                            ClassPid = element(4, Receiver),
                            beamtalk_object_class:class_send(ClassPid, Selector, Args);
                        false ->
                            Pid = element(4, Receiver),
                            %% BT-886: Validate PID before dispatching.
                            %% When class registration is incomplete, the actor
                            %% record may contain an invalid PID (e.g., undefined).
                            case is_pid(Pid) of
                                true ->
                                    %% BT-918 / ADR 0043: sync-by-default — use gen_server:call
                                    %% so the send returns the value directly, not a Future.
                                    beamtalk_actor:sync_send(Pid, Selector, Args);
                                false ->
                                    ClassName = element(2, Receiver),
                                    Error = beamtalk_error:new(
                                        actor_dead,
                                        ClassName,
                                        Selector,
                                        <<"Actor process is not available — class may not be fully registered">>
                                    ),
                                    error(beamtalk_exception_handler:ensure_wrapped(Error))
                            end
                    end
            end;
        false ->
            beamtalk_primitive:send(Receiver, Selector, Args)
    end.

%% @doc Fire-and-forget cast to an actor receiver (BT-920).
%%
%% For actors, extracts the PID and calls beamtalk_actor:cast_send/3.
%% Returns ok regardless of receiver type — non-actors are silently ignored
%% since cast has no meaningful semantics for primitives.
%% Auto-awaits futures before dispatching (BT-840 parity with send/3).
-spec cast(term(), atom(), list()) -> ok.
cast({beamtalk_future, _} = Future, Selector, Args) ->
    Value = beamtalk_future:await(Future),
    cast(Value, Selector, Args);
cast(Receiver, Selector, Args) ->
    case is_actor(Receiver) of
        true ->
            case element(2, Receiver) of
                'Metaclass' ->
                    %% Metaclass objects cannot receive cast messages
                    ok;
                _ ->
                    case beamtalk_class_registry:is_class_object(Receiver) of
                        true ->
                            %% Class objects cannot receive cast messages
                            ok;
                        false ->
                            Pid = element(4, Receiver),
                            case is_pid(Pid) of
                                true ->
                                    beamtalk_actor:cast_send(Pid, Selector, Args);
                                false ->
                                    %% Dead actor: cast is fire-and-forget, silently ignore
                                    ok
                            end
                    end
            end;
        false ->
            %% Primitive receiver: cast has no effect
            ok
    end.

%% @doc Check if a value is a beamtalk actor (beamtalk_object record).
%%
%% Uses safe short-circuit evaluation to avoid badarg on non-tuple values.
-spec is_actor(term()) -> boolean().
is_actor(X) when is_tuple(X) ->
    tuple_size(X) =:= 4 andalso element(1, X) =:= beamtalk_object;
is_actor(_) ->
    false.
