// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

// Stdlib tests for Erlang interop (ADR 0028, BT-677, BT-682)

TestCase subclass: ErlangInteropTest

  testModuleProxyConstruction =>
    Erlang lists.
    Erlang maps.
    Erlang erlang.
    // Proxy class is ErlangModule
    self assert: ((Erlang lists) class) equals: ErlangModule

  testErlangFunctionCallsKeywordMessages =>
    // Single keyword: lists:reverse/1
    self assert: (Erlang lists reverse: #(3, 2, 1)) equals: #(1, 2, 3).
    // Multi-keyword: maps:merge/2
    self assert: (Erlang maps merge: #{#a => 1} with: #{#b => 2}) equals: #{#a => 1, #b => 2}.
    // lists:seq/2
    self assert: (Erlang lists seq: 1 with: 5) equals: #(1, 2, 3, 4, 5).
    // lists:nth/2
    self assert: (Erlang lists nth: 2 with: #(10, 20, 30)) equals: 20

  testErlangFunctionCallsZeroArgUnaryOnProxy =>
    // erlang:node/0
    (Erlang erlang) node

  testCachedProxy =>
    // Store proxy in variable and reuse
    proxy := Erlang lists.
    self assert: (proxy reverse: #(1, 2, 3)) equals: #(3, 2, 1).
    proxy reverse: #(#a, #b, #c)

  testClassProtocolOnErlang =>
    // Class-protocol selectors should NOT generate proxy maps
    self assert: (Erlang class) equals: #Metaclass

  testProxyObjectProtocol =>
    proxy := Erlang lists.
    self assert: (proxy class) equals: ErlangModule.
    self assert: (proxy == proxy).
    self deny: (proxy isNil).
    self assert: (proxy notNil)

  testBt682DirectCallVsProxyEquivalence =>
    // Single-arg keyword: direct vs proxy
    directResult := Erlang lists reverse: #(1, 2, 3).
    // produce identical results.
    proxyLists := Erlang lists.
    // Verify optimized (direct call) and unoptimized (cached proxy) paths
    proxyResult := proxyLists reverse: #(1, 2, 3).
    self assert: (directResult =:= proxyResult).
    // Multi-arg keyword: direct vs proxy
    directSeq := Erlang lists seq: 1 with: 5.
    proxySeq := proxyLists seq: 1 with: 5.
    self assert: (directSeq =:= proxySeq)
