// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

//! Page scaffolding: headers, footers, sidebar, and hierarchy tree.
//!
//! **DDD Context:** CLI / Documentation

use std::collections::HashMap;
use std::fmt::Write as _;

use super::extractor::ClassInfo;
use super::renderer::html_escape;

/// Generate HTML page header with top navigation bar.
///
/// `css` is the relative path to the stylesheet.
/// `nav_prefix` is prepended to cross-site navigation links (e.g. `"../"` when
/// in a subdirectory).  An empty `nav_prefix` signals standalone API-only mode
/// (generated by `beamtalk doc`): in that case the prose-docs links (`/docs/`,
/// `/apidocs/`) are omitted because those pages do not exist in the output.
pub(super) fn page_header(title: &str, css: &str, nav_prefix: &str) -> String {
    // In site mode (nav_prefix non-empty) we have cross-links to prose docs and
    // the root.  In standalone mode we only show the GitHub link.
    let site_links = if nav_prefix.is_empty() {
        String::new()
    } else {
        format!(
            "<a href=\"{nav_prefix}docs/language-features.html\">Language</a>\n\
             <a href=\"{nav_prefix}docs/architecture.html\">Architecture</a>\n\
             <a href=\"{nav_prefix}apidocs/\">API</a>\n"
        )
    };
    let logo_href = if nav_prefix.is_empty() {
        "index.html".to_string()
    } else {
        nav_prefix.to_string()
    };
    format!(
        "<!DOCTYPE html>\n\
         <html lang=\"en\">\n\
         <head>\n\
         <meta charset=\"utf-8\">\n\
         <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\
         <title>{title}</title>\n\
         <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\">\n\
         <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin>\n\
         <link href=\"https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap\" rel=\"stylesheet\">\n\
         <link rel=\"stylesheet\" href=\"{css}\">\n\
         </head>\n\
         <body>\n\
         <header class=\"top-nav\">\n\
         <a class=\"nav-logo\" href=\"{logo_href}\">Beamtalk</a>\n\
         <nav class=\"nav-links\">\n\
         {site_links}\
         <a href=\"https://github.com/jamesc/beamtalk\" class=\"nav-github\">GitHub ↗</a>\n\
         </nav>\n\
         </header>\n",
    )
}

/// Generate HTML page footer with search.js.
pub(super) fn page_footer() -> String {
    page_footer_with_search(Some("search.js"))
}

/// Generate HTML page footer with optional search.js path.
fn page_footer_with_search(search_js: Option<&str>) -> String {
    let script = search_js
        .map(|js| format!("<script src=\"{js}\"></script>\n"))
        .unwrap_or_default();
    format!(
        "<footer>Generated by <code>beamtalk doc</code></footer>\n\
         </div>\n\
         {script}\
         </body>\n\
         </html>\n"
    )
}

/// Simple page footer without search.js (for landing and prose pages).
pub(super) fn page_footer_simple() -> String {
    page_footer_with_search(None)
}

/// Build sidebar HTML with class list navigation.
///
/// `asset_prefix` is prepended to cross-site links (e.g., `"../"` when in a subdirectory).
pub(super) fn build_sidebar_html(classes: &[ClassInfo], asset_prefix: &str) -> String {
    let mut html = String::new();
    html.push_str("<nav class=\"sidebar\">\n");

    html.push_str("<div class=\"sidebar-search-wrap\">\n");
    html.push_str(
        "<input type=\"search\" class=\"sidebar-search\" \
         id=\"sidebar-search\" placeholder=\"Search classes…\" \
         aria-label=\"Search classes\" \
         autocomplete=\"off\">\n",
    );
    html.push_str("</div>\n");

    // Cross-navigation links (only when in a subdirectory)
    if !asset_prefix.is_empty() {
        html.push_str("<div class=\"sidebar-section-label\">Navigate</div>\n");
        html.push_str("<ul class=\"sidebar-nav\">\n");
        let _ = writeln!(html, "<li><a href=\"{asset_prefix}\">Home</a></li>");
        let _ = writeln!(
            html,
            "<li><a href=\"{asset_prefix}docs/language-features.html\">Documentation</a></li>"
        );
        html.push_str("</ul>\n");
    }

    html.push_str("<div class=\"sidebar-section-label\">API Reference</div>\n");
    html.push_str("<ul class=\"sidebar-nav\" id=\"sidebar-nav\">\n");

    for class in classes {
        let _ = writeln!(
            html,
            "<li><a href=\"{name}.html\">{name}</a></li>",
            name = html_escape(&class.name),
        );
    }

    html.push_str("</ul>\n</nav>\n");
    html
}

/// Write class hierarchy tree on the index page.
pub(super) fn write_hierarchy_tree(html: &mut String, classes: &[ClassInfo]) {
    // Build parent → children map
    let mut children: HashMap<String, Vec<&str>> = HashMap::new();

    for class in classes {
        if let Some(ref superclass) = class.superclass {
            children
                .entry(superclass.clone())
                .or_default()
                .push(&class.name);
        }
    }

    // Sort children alphabetically
    for v in children.values_mut() {
        v.sort_unstable();
    }

    // Build name → first-line summary map
    let summaries: HashMap<&str, &str> = classes
        .iter()
        .filter_map(|c| {
            c.doc_comment
                .as_ref()
                .and_then(|d| d.lines().next())
                .map(|line| (c.name.as_str(), line))
        })
        .collect();

    // Find roots (classes without a parent in our set)
    let class_names: std::collections::HashSet<&str> =
        classes.iter().map(|c| c.name.as_str()).collect();
    let mut roots: Vec<&str> = classes
        .iter()
        .filter(|c| {
            c.superclass
                .as_ref()
                .is_none_or(|s| !class_names.contains(s.as_str()))
        })
        .map(|c| c.name.as_str())
        .collect();
    roots.sort_unstable();

    if roots.is_empty() {
        return;
    }

    html.push_str("<div class=\"hierarchy-tree\">\n");
    html.push_str("<h2>Class Hierarchy</h2>\n");
    html.push_str("<ul>\n");
    for root in &roots {
        write_hierarchy_node(html, root, &children, &summaries);
    }
    html.push_str("</ul>\n</div>\n");
}

/// Recursively write a hierarchy tree node.
fn write_hierarchy_node(
    html: &mut String,
    name: &str,
    children: &HashMap<String, Vec<&str>>,
    summaries: &HashMap<&str, &str>,
) {
    let escaped = html_escape(name);
    let _ = write!(html, "<li><a href=\"{escaped}.html\">{escaped}</a>");

    if let Some(summary) = summaries.get(name) {
        // Strip a leading "ClassName — " prefix if present (common doc style)
        let separator = " — ";
        let text = summary
            .find(separator)
            .map_or(summary, |i| summary[i + separator.len()..].trim());
        if !text.is_empty() {
            let _ = write!(
                html,
                " <span class=\"class-summary\">{}</span>",
                html_escape(text)
            );
        }
    }

    if let Some(kids) = children.get(name) {
        html.push_str("\n<ul>\n");
        for kid in kids {
            write_hierarchy_node(html, kid, children, summaries);
        }
        html.push_str("</ul>\n");
    }

    html.push_str("</li>\n");
}
