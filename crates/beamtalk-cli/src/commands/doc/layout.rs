// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

//! Page scaffolding: headers, footers, sidebar, and hierarchy tree.
//!
//! **DDD Context:** CLI / Documentation

use std::collections::HashMap;
use std::fmt::Write as _;

use super::extractor::ClassInfo;
use super::renderer::html_escape;

/// Generate HTML page header with sidebar toggle.
pub(super) fn page_header(title: &str, css_path: Option<&str>) -> String {
    let css = css_path.unwrap_or("style.css");
    format!(
        "<!DOCTYPE html>\n\
         <html lang=\"en\">\n\
         <head>\n\
         <meta charset=\"utf-8\">\n\
         <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\
         <title>{title}</title>\n\
         <link rel=\"stylesheet\" href=\"{css}\">\n\
         </head>\n\
         <body>\n\
         <button class=\"sidebar-toggle\" onclick=\"document.querySelector('.sidebar')\
         .classList.toggle('open')\" aria-label=\"Toggle navigation\">☰</button>\n",
    )
}

/// Generate HTML page footer with search.js.
pub(super) fn page_footer() -> String {
    page_footer_with_search(Some("search.js"))
}

/// Generate HTML page footer with optional search.js path.
fn page_footer_with_search(search_js: Option<&str>) -> String {
    let script = search_js
        .map(|js| format!("<script src=\"{js}\"></script>\n"))
        .unwrap_or_default();
    format!(
        "<footer>Generated by <code>beamtalk doc</code></footer>\n\
         </div>\n\
         {script}\
         </body>\n\
         </html>\n"
    )
}

/// Simple page footer without search.js (for landing and prose pages).
pub(super) fn page_footer_simple() -> String {
    page_footer_with_search(None)
}

/// Build sidebar HTML with class list navigation.
///
/// `asset_prefix` is prepended to cross-site links (e.g., `"../"` when in a subdirectory).
pub(super) fn build_sidebar_html(classes: &[ClassInfo], asset_prefix: &str) -> String {
    let mut html = String::new();
    html.push_str("<nav class=\"sidebar\">\n");
    html.push_str("<div class=\"sidebar-header\">\n");
    let _ = writeln!(
        html,
        "<h2><a href=\"{asset_prefix}index.html\">Beamtalk</a></h2>"
    );
    html.push_str(
        "<input type=\"search\" class=\"sidebar-search\" \
         id=\"sidebar-search\" placeholder=\"Search classes…\" \
         aria-label=\"Search classes\" \
         autocomplete=\"off\">\n",
    );
    html.push_str("</div>\n");

    // Cross-navigation links
    if !asset_prefix.is_empty() {
        html.push_str("<div class=\"sidebar-section\">\n");
        let _ = writeln!(
            html,
            "<a href=\"{asset_prefix}\" class=\"sidebar-home-link\">← Home</a>"
        );
        let _ = writeln!(
            html,
            "<a href=\"{asset_prefix}docs/language-features.html\" class=\"sidebar-docs-link\">Documentation</a>"
        );
        html.push_str("</div>\n");
    }

    html.push_str("<ul class=\"sidebar-nav\" id=\"sidebar-nav\">\n");

    for class in classes {
        let _ = writeln!(
            html,
            "<li><a href=\"{name}.html\">{name}</a></li>",
            name = html_escape(&class.name),
        );
    }

    html.push_str("</ul>\n</nav>\n");
    html
}

/// Write class hierarchy tree on the index page.
pub(super) fn write_hierarchy_tree(html: &mut String, classes: &[ClassInfo]) {
    // Build parent → children map
    let mut children: HashMap<String, Vec<&str>> = HashMap::new();

    for class in classes {
        if let Some(ref superclass) = class.superclass {
            children
                .entry(superclass.clone())
                .or_default()
                .push(&class.name);
        }
    }

    // Sort children alphabetically
    for v in children.values_mut() {
        v.sort_unstable();
    }

    // Find roots (classes without a parent in our set)
    let class_names: std::collections::HashSet<&str> =
        classes.iter().map(|c| c.name.as_str()).collect();
    let mut roots: Vec<&str> = classes
        .iter()
        .filter(|c| {
            c.superclass
                .as_ref()
                .is_none_or(|s| !class_names.contains(s.as_str()))
        })
        .map(|c| c.name.as_str())
        .collect();
    roots.sort_unstable();

    if roots.is_empty() {
        return;
    }

    html.push_str("<div class=\"hierarchy-tree\">\n");
    html.push_str("<h2>Class Hierarchy</h2>\n");
    html.push_str("<ul>\n");
    for root in &roots {
        write_hierarchy_node(html, root, &children);
    }
    html.push_str("</ul>\n</div>\n");
}

/// Recursively write a hierarchy tree node.
fn write_hierarchy_node(html: &mut String, name: &str, children: &HashMap<String, Vec<&str>>) {
    let _ = write!(
        html,
        "<li><a href=\"{name}.html\">{name}</a>",
        name = html_escape(name),
    );

    if let Some(kids) = children.get(name) {
        html.push_str("\n<ul>\n");
        for kid in kids {
            write_hierarchy_node(html, kid, children);
        }
        html.push_str("</ul>\n");
    }

    html.push_str("</li>\n");
}
