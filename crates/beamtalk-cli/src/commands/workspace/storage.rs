// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

//! File I/O operations for workspace metadata, cookies, and node information.
//!
//! **DDD Context:** CLI

use std::fs;
#[cfg(unix)]
use std::io::Write;
use std::path::{Path, PathBuf};

use fs2::FileExt;
use miette::{IntoDiagnostic, Result, miette};
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};

/// Workspace metadata stored in ~/.beamtalk/workspaces/{id}/metadata.json
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WorkspaceMetadata {
    /// Unique identifier (hash of project path or user-provided name).
    pub workspace_id: String,
    /// Absolute path to the project directory.
    pub project_path: PathBuf,
    /// Unix timestamp (seconds) when the workspace was created.
    pub created_at: u64,
}

/// Node information stored in ~/.beamtalk/workspaces/{id}/node.info
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NodeInfo {
    /// Erlang node name (e.g. `beamtalk_workspace_abc123@localhost`).
    pub node_name: String,
    /// TCP port the REPL server is listening on.
    pub port: u16,
    /// OS process ID of the BEAM node.
    pub pid: u32,
    /// Process start time, representation is platform-dependent.
    /// On Linux, this is clock ticks since boot from `/proc/{pid}/stat` field 22.
    /// `None` for backward compat with old node.info files or non-Linux platforms.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub start_time: Option<u64>,
    /// Nonce for stale port file detection (BT-611).
    /// Generated by `beamtalk_repl_server` on startup and written to port file.
    /// `None` for backward compat with old port files.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nonce: Option<String>,
    /// Bind address the workspace is listening on (BT-694).
    /// Stored so that reconnection uses the correct address instead of
    /// hardcoding `127.0.0.1`. `None` defaults to `127.0.0.1` for backward
    /// compat with old node.info files.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bind_addr: Option<String>,
}

impl NodeInfo {
    /// Return the host address to use when connecting to this workspace.
    ///
    /// Uses the stored `bind_addr` if present, falling back to `127.0.0.1`.
    /// For `0.0.0.0` (all interfaces), connects via `127.0.0.1` since the
    /// workspace is reachable on loopback.
    pub fn connect_host(&self) -> &str {
        match self.bind_addr.as_deref() {
            Some("0.0.0.0") | None => "127.0.0.1",
            Some(addr) => addr,
        }
    }
}

/// Generate a workspace ID from a project path.
/// Uses SHA256 hash of the absolute path.
pub fn generate_workspace_id(project_path: &Path) -> Result<String> {
    let absolute = project_path.canonicalize().into_diagnostic()?;
    let path_str = absolute
        .to_str()
        .ok_or_else(|| miette!("Project path contains invalid UTF-8: {:?}", absolute))?;

    let mut hasher = Sha256::new();
    hasher.update(path_str.as_bytes());
    let result = hasher.finalize();

    // Use first 12 hex chars for readability
    Ok(format!("{result:x}")[..12].to_string())
}

/// Validate a user-provided workspace name.
pub(super) fn validate_workspace_name(name: &str) -> Result<()> {
    if name.is_empty() {
        return Err(miette!("Workspace name cannot be empty"));
    }

    let valid = name
        .chars()
        .all(|c| c.is_ascii_alphanumeric() || c == '-' || c == '_');
    if !valid {
        return Err(miette!(
            "Workspace name must contain only letters, numbers, '-' or '_'"
        ));
    }

    Ok(())
}

/// Determine workspace ID from project path or explicit name.
pub fn workspace_id_for(project_path: &Path, workspace_name: Option<&str>) -> Result<String> {
    match workspace_name {
        Some(name) => {
            let trimmed = name.trim();
            if trimmed.is_empty() {
                return Err(miette!("Workspace name cannot be empty or whitespace-only"));
            }
            validate_workspace_name(trimmed)?;
            Ok(trimmed.to_string())
        }
        None => generate_workspace_id(project_path),
    }
}

/// Get the base directory for all workspaces (`~/.beamtalk/workspaces/`).
pub(super) fn workspaces_base_dir() -> Result<PathBuf> {
    let home = dirs::home_dir().ok_or_else(|| miette!("Could not determine home directory"))?;
    Ok(home.join(".beamtalk").join("workspaces"))
}

/// Get the workspace directory for a given ID.
pub fn workspace_dir(workspace_id: &str) -> Result<PathBuf> {
    Ok(workspaces_base_dir()?.join(workspace_id))
}

/// Check if a workspace exists.
pub fn workspace_exists(workspace_id: &str) -> Result<bool> {
    let dir = workspace_dir(workspace_id)?;
    Ok(dir.exists() && dir.join("metadata.json").exists())
}

/// Get workspace metadata.
pub fn get_workspace_metadata(workspace_id: &str) -> Result<WorkspaceMetadata> {
    let metadata_path = workspace_dir(workspace_id)?.join("metadata.json");
    let content = fs::read_to_string(&metadata_path).into_diagnostic()?;
    serde_json::from_str(&content).into_diagnostic()
}

/// Save workspace metadata.
pub fn save_workspace_metadata(metadata: &WorkspaceMetadata) -> Result<()> {
    let dir = workspace_dir(&metadata.workspace_id)?;
    fs::create_dir_all(&dir).into_diagnostic()?;

    let metadata_path = dir.join("metadata.json");
    let content = serde_json::to_string_pretty(metadata).into_diagnostic()?;
    fs::write(metadata_path, content).into_diagnostic()?;

    Ok(())
}

/// Generate a unique Erlang cookie for a workspace.
///
/// Uses URL-safe base64 (RFC 4648 §5) to avoid `+` and `/` characters,
/// which Erlang's `-args_file` parser misinterprets as ERTS VM flags when
/// they appear at the start of a token (e.g. `-setcookie +abc` treats `+abc`
/// as an ERTS flag rather than the cookie value).
pub fn generate_cookie() -> String {
    use rand::Rng;
    let mut rng = rand::rng();
    let mut bytes = vec![0u8; 24];
    rng.fill_bytes(&mut bytes);
    base64::Engine::encode(&base64::engine::general_purpose::URL_SAFE, &bytes)
}

/// Save workspace cookie with secure permissions (owner read/write only).
///
/// On Unix, the file is created with mode 0600 to avoid a TOCTOU race where
/// the cookie could briefly be world-readable. Permissions are also enforced
/// via `fchmod` on the open file descriptor so that pre-existing files with
/// overly-permissive modes (e.g. from older versions) are tightened to 0600.
pub fn save_workspace_cookie(workspace_id: &str, cookie: &str) -> Result<()> {
    let cookie_path = workspace_dir(workspace_id)?.join("cookie");

    #[cfg(unix)]
    {
        use std::os::unix::fs::{OpenOptionsExt, PermissionsExt};

        let mut file = fs::OpenOptions::new()
            .write(true)
            .create(true)
            .truncate(true)
            .mode(0o600)
            .open(&cookie_path)
            .into_diagnostic()?;

        // Ensure 0600 even on overwrite of a pre-existing file (uses fchmod).
        file.set_permissions(fs::Permissions::from_mode(0o600))
            .into_diagnostic()?;

        file.write_all(cookie.as_bytes()).into_diagnostic()?;
    }

    #[cfg(not(unix))]
    {
        fs::write(&cookie_path, cookie).into_diagnostic()?;
    }

    Ok(())
}

/// Read workspace cookie.
pub fn read_workspace_cookie(workspace_id: &str) -> Result<String> {
    let cookie_path = workspace_dir(workspace_id)?.join("cookie");
    fs::read_to_string(cookie_path).into_diagnostic()
}

/// Get node info for a workspace.
pub fn get_node_info(workspace_id: &str) -> Result<Option<NodeInfo>> {
    let node_info_path = workspace_dir(workspace_id)?.join("node.info");

    if !node_info_path.exists() {
        return Ok(None);
    }

    let content = fs::read_to_string(&node_info_path).into_diagnostic()?;
    let info: NodeInfo = serde_json::from_str(&content).into_diagnostic()?;
    Ok(Some(info))
}

/// Save node info for a workspace.
pub fn save_node_info(workspace_id: &str, info: &NodeInfo) -> Result<()> {
    let node_info_path = workspace_dir(workspace_id)?.join("node.info");
    let content = serde_json::to_string_pretty(info).into_diagnostic()?;
    fs::write(node_info_path, content).into_diagnostic()?;
    Ok(())
}

/// Read the actual port and optional nonce from the port file written by `beamtalk_repl_server`.
/// Port file format (BT-611): `PORT\nNONCE` (two lines).
/// Returns `None` if the file doesn't exist or can't be parsed.
pub(super) fn read_port_file(workspace_id: &str) -> Result<Option<(u16, Option<String>)>> {
    let port_file_path = workspace_dir(workspace_id)?.join("port");

    if !port_file_path.exists() {
        return Ok(None);
    }

    let content = fs::read_to_string(&port_file_path).into_diagnostic()?;
    let mut lines = content.lines();
    if let Some(port_line) = lines.next() {
        if let Ok(port) = port_line.trim().parse::<u16>() {
            let nonce = lines
                .next()
                .map(|s| s.trim().to_string())
                .filter(|s| !s.is_empty());
            Ok(Some((port, nonce)))
        } else {
            tracing::warn!("Invalid port file content: {content:?}");
            Ok(None)
        }
    } else {
        Ok(None)
    }
}

/// Read process start time from `/proc/{pid}/stat` (field 22 per proc(5)).
/// Returns `None` if the process doesn't exist or the file can't be read.
/// Linux-only: `/proc` filesystem does not exist on macOS/BSD.
#[cfg(target_os = "linux")]
pub(super) fn read_proc_start_time(pid: u32) -> Option<u64> {
    let stat_path = format!("/proc/{pid}/stat");
    let content = fs::read_to_string(stat_path).ok()?;
    // Fields are space-separated, but comm (field 2) may contain spaces/parens.
    // Find the LAST ')' to handle pathological comm names.
    let after_comm = content.rsplit_once(')')?.1;
    // Fields after comm: state(3), ppid(4), ... starttime is field 22 (1-indexed),
    // which is the 20th field after comm (fields 3..22 = 20 fields).
    let starttime_str = after_comm.split_whitespace().nth(19)?;
    starttime_str.parse::<u64>().ok()
}

/// Remove a single file, ignoring `NotFound` but propagating other errors.
///
/// Used by stale-file cleanup to avoid TOCTOU races (`exists()` + `remove_file()`
/// is racy if another process creates/removes the file between the two calls).
pub(super) fn remove_file_if_exists(path: &std::path::Path) -> Result<()> {
    if let Err(err) = fs::remove_file(path) {
        if err.kind() != std::io::ErrorKind::NotFound {
            return Err(miette!(
                "Failed to remove stale file {}: {err}",
                path.display()
            ));
        }
    }
    Ok(())
}

/// Remove stale runtime files (`node.info`, `port`, `pid`, `starting`) from a workspace directory.
///
/// These files are written during workspace startup and must be cleaned before
/// restarting a node — a stale `port` file can cause `start_detached_node` to
/// connect to the wrong BEAM node, and a stale `pid` file can report the wrong
/// process.  The `starting` tombstone is written at the very beginning of
/// `start_detached_node` and removed on success; its presence here indicates a
/// partial startup that was interrupted (BT-969).
///
/// Called by:
/// - `cleanup_stale_node_info` — after detecting an orphaned workspace
/// - `start_detached_node` (via `process.rs`) — before spawning a new BEAM node
pub fn remove_stale_runtime_files(workspace_id: &str) -> Result<()> {
    let ws_dir = workspace_dir(workspace_id)?;
    remove_file_if_exists(&ws_dir.join("node.info"))?;
    remove_file_if_exists(&ws_dir.join("port"))?;
    remove_file_if_exists(&ws_dir.join("pid"))?;
    remove_file_if_exists(&ws_dir.join("starting"))?;
    Ok(())
}

/// Clean up stale node info and runtime files for a workspace.
///
/// Removes `node.info`, `port`, and `pid` files. Use when an orphaned workspace
/// is detected (stale `node.info` but node not running) or after graceful shutdown.
pub fn cleanup_stale_node_info(workspace_id: &str) -> Result<()> {
    remove_stale_runtime_files(workspace_id)
}

/// Acquire an exclusive advisory lock for workspace creation.
///
/// Returns a locked `File` handle. The lock is released when the file is dropped.
/// The lockfile is created at `~/.beamtalk/workspaces/{workspace_id}.lock`.
pub(super) fn acquire_workspace_lock(workspace_id: &str) -> Result<fs::File> {
    let base = workspaces_base_dir()?;
    fs::create_dir_all(&base).into_diagnostic()?;

    let lockfile_path = base.join(format!("{workspace_id}.lock"));
    let lockfile = fs::OpenOptions::new()
        .create(true)
        .write(true)
        .truncate(false)
        .open(&lockfile_path)
        .into_diagnostic()?;

    lockfile.lock_exclusive().into_diagnostic()?;
    Ok(lockfile)
}

#[cfg(test)]
mod tests {
    use super::*;

    /// Verify that `remove_stale_runtime_files` removes all known runtime files
    /// including the `starting` tombstone introduced in BT-969.
    #[test]
    fn test_remove_stale_runtime_files_removes_starting_tombstone() {
        let ws_id = format!("test_stale_tombstone_{}", std::process::id());
        let ws_dir = workspaces_base_dir().unwrap().join(&ws_id);
        fs::create_dir_all(&ws_dir).unwrap();

        // Write all runtime files including the tombstone.
        for name in &["node.info", "port", "pid", "starting"] {
            fs::write(ws_dir.join(name), b"dummy").unwrap();
        }

        remove_stale_runtime_files(&ws_id).expect("remove_stale_runtime_files should not fail");

        for name in &["node.info", "port", "pid", "starting"] {
            assert!(
                !ws_dir.join(name).exists(),
                "{name} should have been removed by remove_stale_runtime_files"
            );
        }

        // Cleanup
        let _ = fs::remove_dir_all(&ws_dir);
    }

    /// Verify that `remove_stale_runtime_files` is idempotent — calling it when
    /// the files are already absent (e.g. after a clean shutdown) must not error.
    #[test]
    fn test_remove_stale_runtime_files_idempotent_on_missing_files() {
        let ws_id = format!("test_stale_idempotent_{}", std::process::id());
        let ws_dir = workspaces_base_dir().unwrap().join(&ws_id);
        fs::create_dir_all(&ws_dir).unwrap();

        // No files written — must succeed without error.
        remove_stale_runtime_files(&ws_id)
            .expect("remove_stale_runtime_files should be idempotent on missing files");

        let _ = fs::remove_dir_all(&ws_dir);
    }
}
