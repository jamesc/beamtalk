// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

//! Beamtalk compiler command-line interface.
//!
//! This is the main entry point for the `beamtalk` command.

use clap::{ArgAction, Parser, Subcommand};
use miette::Result;

/// BEAM bytecode compiler integration (Core Erlang → `.beam`).
pub mod beam_compiler;
/// CLI subcommand implementations (build, repl, test, etc.).
mod commands;
/// Diagnostic formatting for compiler errors and warnings.
mod diagnostic;
/// Shared path utilities (`~/.beamtalk/` and workspace directories).
mod paths;

/// Beamtalk: A Smalltalk-inspired language for the BEAM VM
#[derive(Debug, Parser)]
#[command(name = "beamtalk")]
#[command(version, about, long_about = None)]
struct Cli {
    /// Increase logging verbosity (-v: debug, -vv+: trace)
    #[arg(short, long, action = ArgAction::Count, global = true)]
    verbose: u8,

    #[command(subcommand)]
    command: Command,
}

/// Available CLI subcommands.
#[derive(Debug, Subcommand)]
enum Command {
    /// Compile Beamtalk source files to BEAM bytecode
    Build {
        /// Source file or directory to compile
        #[arg(default_value = ".")]
        path: String,

        /// Allow @primitive pragmas in non-stdlib code (advanced FFI use)
        #[arg(long)]
        allow_primitives: bool,

        /// Compile in stdlib mode (enables @primitive without warnings)
        #[arg(long)]
        stdlib_mode: bool,

        /// Suppress warning diagnostics
        #[arg(long)]
        no_warnings: bool,
    },

    /// Compile the standard library (`lib/*.bt` → `runtime/apps/beamtalk_stdlib/ebin/`)
    BuildStdlib {
        /// Suppress per-file compilation output
        #[arg(long, short)]
        quiet: bool,
    },

    /// Compile and run a Beamtalk program
    Run {
        /// Source file or directory to compile and run
        #[arg(default_value = ".")]
        path: String,
    },

    /// Create a new Beamtalk project
    New {
        /// Name of the project to create
        name: String,
    },

    /// Start an interactive REPL
    Repl {
        /// Port for the REPL backend (default: 0 = OS-assigned, or `BEAMTALK_REPL_PORT` env var)
        #[arg(long)]
        port: Option<u16>,

        /// Node name for Erlang distribution (default: `BEAMTALK_NODE_NAME` env var)
        #[arg(long)]
        node: Option<String>,

        /// Start node in foreground instead of detached workspace (for debugging)
        #[arg(long)]
        foreground: bool,

        /// Explicit workspace name (default: auto-detect from current directory)
        #[arg(long)]
        workspace: Option<String>,

        /// Disable auto-cleanup (workspace persists even when idle)
        #[arg(long)]
        persistent: bool,

        /// Request automatic cleanup of detached workspace on REPL exit (ephemeral mode).
        /// In detached workspace mode (default, without --foreground), attempts to stop the associated BEAM node when the REPL session ends; failures are logged to stderr.
        #[arg(long, short = 'e')]
        ephemeral: bool,

        /// Maximum idle timeout in seconds before auto-cleanup (default: 14400 = 4 hours)
        /// Can also be set via `BEAMTALK_WORKSPACE_TIMEOUT` environment variable
        #[arg(long)]
        timeout: Option<u64>,

        /// Disable colored output (also respects `NO_COLOR` environment variable)
        #[arg(long)]
        no_color: bool,

        /// Bind address for the REPL WebSocket server.
        /// Use "tailscale" to auto-detect Tailscale interface,
        /// or an IP address like "192.168.1.5" or "0.0.0.0".
        /// Default: 127.0.0.1 (localhost only)
        #[arg(long)]
        bind: Option<String>,

        /// Suppress the safety warning when binding to a non-loopback address
        #[arg(long)]
        confirm_network: bool,

        /// Enable TLS for Erlang distribution (mTLS).
        /// Requires certificates generated by `beamtalk tls init`.
        #[arg(long)]
        tls: bool,

        /// Start browser workspace (serves HTML UI at `http://localhost:<port>/`)
        #[arg(long)]
        web: bool,

        /// Port for the browser workspace HTTP server (default: same as REPL WebSocket port).
        /// Only used with --web.
        #[arg(long, requires = "web")]
        web_port: Option<u16>,
    },

    /// Check source files for errors without compiling
    Check {
        /// Source file or directory to check
        #[arg(default_value = ".")]
        path: String,
    },

    /// Stream Transcript output from a running workspace
    Transcript {
        /// Explicit workspace name (default: auto-detect from current directory)
        #[arg(long)]
        workspace: Option<String>,

        /// Display last N entries from ring buffer on connect
        #[arg(long)]
        recent: Option<usize>,
    },

    /// Manage workspaces (list, stop, status, create)
    Workspace {
        #[command(subcommand)]
        action: commands::workspace::cli::WorkspaceCommand,
    },

    /// Run compiled stdlib tests (ADR 0014 Phase 1)
    TestStdlib {
        /// File or directory containing .bt test files
        #[arg(default_value = "bootstrap-test")]
        path: String,

        /// Suppress warning diagnostics when compiling test fixtures
        #[arg(long)]
        no_warnings: bool,

        /// Suppress per-file output, show only summary
        #[arg(long, short)]
        quiet: bool,

        /// Show detailed test output including `EUnit` verbose mode
        #[arg(long = "show-output")]
        show_output: bool,
    },

    /// Run `BUnit` tests — discover and run `TestCase` subclasses (ADR 0014 Phase 2)
    Test {
        /// Test file or directory containing .bt test files
        #[arg(default_value = "test")]
        path: String,
    },

    /// Generate HTML API documentation from source files (ADR 0008)
    Doc {
        /// Source file or directory containing .bt files
        #[arg(default_value = "stdlib/src")]
        path: String,

        /// Output directory for generated HTML
        #[arg(long, default_value = "docs/api")]
        output: String,

        /// Build full documentation site (landing page + API docs + prose docs)
        #[arg(long)]
        site: bool,

        /// Directory containing prose documentation markdown files
        #[arg(long, default_value = "docs")]
        docs_path: String,
    },

    /// Manage TLS certificates for Erlang distribution security (ADR 0020)
    Tls {
        #[command(subcommand)]
        action: commands::tls::TlsCommand,
    },

    /// Attach to a running workspace (without starting one)
    Attach {
        /// Workspace ID to connect to (from `beamtalk workspace list`)
        workspace: Option<String>,

        /// Connect to a workspace at an explicit localhost port
        #[arg(long, conflicts_with = "workspace")]
        port: Option<u16>,

        /// Erlang cookie for authentication (required with --port)
        #[arg(long, requires = "port")]
        cookie: Option<String>,

        /// Disable colored output (also respects `NO_COLOR` environment variable)
        #[arg(long)]
        no_color: bool,
    },
}

/// CLI entry point: parse arguments and dispatch to the appropriate subcommand.
#[expect(
    clippy::too_many_lines,
    reason = "top-level dispatch — each arm is a one-liner"
)]
fn main() -> Result<()> {
    let cli = Cli::parse();

    // Initialize tracing when explicitly requested.
    // Default is still no logs to avoid stderr interference with E2E tests.
    let has_rust_log = std::env::var("RUST_LOG").is_ok();
    if has_rust_log || cli.verbose > 0 {
        let env_filter = if has_rust_log {
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("warn"))
        } else {
            // Target must match Rust module paths (`beamtalk_cli`, `beamtalk_core`).
            // `beamtalk=…` only matches `beamtalk::*`, not `beamtalk_cli`.
            let directive = if cli.verbose == 1 {
                "beamtalk_cli=debug,beamtalk_core=debug"
            } else {
                "beamtalk_cli=trace,beamtalk_core=trace"
            };
            tracing_subscriber::EnvFilter::new(directive)
        };

        let _ = tracing_subscriber::fmt()
            .with_env_filter(env_filter)
            .try_init();
    }

    // Install miette's fancy error handler
    miette::set_hook(Box::new(|_| {
        Box::new(
            miette::MietteHandlerOpts::new()
                .terminal_links(true)
                .unicode(true)
                .context_lines(3)
                .build(),
        )
    }))?;

    let result = match cli.command {
        Command::Build {
            path,
            allow_primitives,
            stdlib_mode,
            no_warnings,
        } => {
            let options = beamtalk_core::CompilerOptions {
                stdlib_mode,
                allow_primitives,
                workspace_mode: false,
                suppress_warnings: no_warnings,
            };
            commands::build::build(&path, &options)
        }
        Command::BuildStdlib { quiet } => commands::build_stdlib::build_stdlib(quiet),
        Command::Run { path } => commands::run::run(&path),
        Command::New { name } => commands::new::new_project(&name),
        Command::Repl {
            port,
            node,
            foreground,
            workspace,
            persistent,
            ephemeral,
            timeout,
            no_color,
            bind,
            confirm_network,
            tls,
            web,
            web_port,
        } => commands::repl::run(
            port,
            node,
            foreground,
            workspace.as_deref(),
            persistent,
            ephemeral,
            timeout,
            no_color,
            bind.as_deref(),
            confirm_network,
            tls,
            web,
            web_port,
        ),
        Command::Transcript { workspace, recent } => {
            commands::transcript::run(workspace.as_deref(), recent)
        }
        Command::Check { path } => {
            println!("Checking: {path}");
            println!("(Not yet implemented)");
            Ok(())
        }
        Command::Workspace { action } => commands::workspace::cli::run(action),
        Command::TestStdlib {
            path,
            no_warnings,
            quiet,
            show_output,
        } => commands::test_stdlib::run_tests(&path, no_warnings, quiet, show_output),
        Command::Test { path } => commands::test::run_tests(&path),
        Command::Doc {
            path,
            output,
            site,
            docs_path,
        } => {
            if site {
                commands::doc::run_site(&path, &docs_path, &output)
            } else {
                commands::doc::run(&path, &output)
            }
        }
        Command::Tls { action } => commands::tls::run(action),
        Command::Attach {
            workspace,
            port,
            cookie,
            no_color,
        } => commands::attach::run(workspace.as_deref(), port, cookie.as_deref(), no_color),
    };

    // Exit with appropriate code
    match result {
        Ok(()) => std::process::exit(0),
        Err(e) => {
            // miette already provides nice error formatting, just display it
            eprintln!("{e:?}");
            std::process::exit(1);
        }
    }
}
