// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

/// Stream examples — lazy pipelines, file processing, collection streaming.
///
/// Stream is Beamtalk's universal interface for sequential data.
/// Operations are lazy (return a Stream) or terminal (force evaluation).
///
/// Try these expressions in the REPL:
///   beamtalk repl
///   > (Stream from: 1) take: 5

// ============================================================
// INFINITE SEQUENCES
// ============================================================

// Natural numbers: 1, 2, 3, ...
(Stream from: 1) take: 10

// Even numbers via pipeline
((Stream from: 1) select: [:n | n isEven]) take: 5

// Powers of two: 1, 2, 4, 8, 16, ...
(Stream from: 1 by: [:n | n * 2]) take: 8

// Count by tens: 0, 10, 20, 30, ...
(Stream from: 0 by: [:n | n + 10]) take: 5

// ============================================================
// PIPELINE COMPOSITION
// ============================================================

// Squares of even numbers
s := Stream from: 1
s := s select: [:n | n isEven]
s := s collect: [:n | n * n]
s take: 5
// => [4, 16, 36, 64, 100]

// Sum of first 100 natural numbers
((Stream from: 1) take: 100) inject: 0 into: [:sum :n | sum + n]
// => 5050

// Find first number whose square exceeds 50
(Stream from: 1) detect: [:n | (n * n) > 50]
// => 8

// ============================================================
// COLLECTION STREAMING
// ============================================================

// Any collection responds to `stream` for lazy processing
#(1, 2, 3, 4, 5) stream
// => a Stream (unevaluated)

// Filter and transform lazily, then materialize
((#(1, 2, 3, 4, 5) stream) select: [:n | n > 2]) asList
// => [3, 4, 5]

// String characters as a stream
('hello' stream) collect: [:ch | ch uppercase]
// => a Stream — call asList to see: ["H","E","L","L","O"]

// Dictionary stream yields Associations
((#{#name => 'Alice', #age => 30} stream) collect: [:a | a value]) asList

// Set streaming
s := ((Set new add: 3) add: 1) add: 2
(s stream select: [:n | n > 1]) asList

// ============================================================
// EAGER vs LAZY — THE BOUNDARY
// ============================================================

// Eager: List select: returns a List immediately
#(1, 2, 3, 4, 5) select: [:n | n > 2]
// => [3, 4, 5]

// Lazy: stream select: returns a Stream (unevaluated)
(#(1, 2, 3, 4, 5) stream) select: [:n | n > 2]
// => Stream (call asList or take: to get values)

// ============================================================
// FILE STREAMING
// ============================================================

// Read file lines lazily — constant memory, safe for large files
// (File lines: 'data.csv') take: 5

// Filter lines matching a pattern
// (File lines: 'app.log') select: [:l | l includes: 'ERROR']

// Count lines in a file
// (File lines: 'data.csv') inject: 0 into: [:count :line | count + 1]

// Block-scoped handle — auto-closes when block exits
// File open: 'data.csv' do: [:handle |
//   handle lines take: 10
// ]

// ============================================================
// PIPELINE INSPECTION
// ============================================================

// printString shows pipeline structure, not values
(Stream from: 1) printString
// => Stream(from: 1)

((Stream from: 1) select: [:n | n isEven]) printString
// => Stream(from: 1) | select: [...]

// ============================================================
// TERMINAL OPERATIONS
// ============================================================

// take: — first N elements as a List
(Stream from: 1) take: 5
// => [1, 2, 3, 4, 5]

// asList — materialize finite stream
(Stream on: #(10, 20, 30)) asList
// => [10, 20, 30]

// do: — iterate for side effects, returns nil
(Stream on: #(1, 2, 3)) do: [:n | Transcript show: n]

// inject:into: — fold/reduce
(Stream on: #(1, 2, 3, 4)) inject: 0 into: [:sum :n | sum + n]
// => 10

// detect: — first match or nil
(Stream on: #(1, 2, 3, 4, 5)) detect: [:n | n > 3]
// => 4

// anySatisfy: / allSatisfy:
(Stream on: #(1, 2, 3)) anySatisfy: [:n | n > 2]
// => true

(Stream on: #(1, 2, 3)) allSatisfy: [:n | n > 0]
// => true
