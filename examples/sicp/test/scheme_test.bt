// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

// SchemeTest â€” BUnit tests for the Scheme metacircular evaluator
//
// Run interactively in the REPL:
//   > :load src/scheme/symbol.bt
//   > :load src/scheme/reader.bt
//   > :load src/scheme/env.bt
//   > :load src/scheme/lambda.bt
//   > :load src/scheme/eval.bt
//   > :load src/scheme/printer.bt
//   > :load test/scheme_test.bt
//   > SchemeTest runAll

TestCase subclass: SchemeTest

  // Helpers shared across tests
  eval: str =>
    reader  := SchemeReader new
    ev      := SchemeEval new
    env     := ev defaultEnv
    ev eval: (reader read: str) in: env

  evalStr: str =>
    SchemePrinter new print: (self eval: str)

  // --- Reader ---

  testReaderInteger =>
    reader := SchemeReader new
    self assert: (reader read: "42") equals: 42

  testReaderSymbol =>
    reader := SchemeReader new
    sym    := reader read: "foo"
    self assert: (sym class =:= SchemeSymbol)

  testReaderBoolTrue =>
    reader := SchemeReader new
    self assert: (reader read: "#t") equals: true

  testReaderBoolFalse =>
    reader := SchemeReader new
    self assert: (reader read: "#f") equals: false

  testReaderString =>
    reader := SchemeReader new
    self assert: (reader read: """hello""") equals: "hello"

  testReaderStringEscapedQuote =>
    reader := SchemeReader new
    self assert: (reader read: """say """"hi"""" please""") equals: "say ""hi"" please"

  testReaderList =>
    reader := SchemeReader new
    lst    := reader read: "(1 2 3)"
    self assert: lst size equals: 3

  // --- Self-evaluating expressions ---

  testEvalInteger =>
    self assert: (self eval: "99") equals: 99

  testEvalBoolTrue =>
    self assert: (self eval: "#t") equals: true

  testEvalBoolFalse =>
    self assert: (self eval: "#f") equals: false

  // --- Arithmetic ---

  testAdd =>
    self assert: (self eval: "(+ 3 4)") equals: 7

  testMul =>
    self assert: (self eval: "(* 6 7)") equals: 42

  testSub =>
    self assert: (self eval: "(- 10 3)") equals: 7

  testDiv =>
    self assert: (self eval: "(/ 10 2)") equals: 5

  // --- Quote ---

  testQuote =>
    result := self eval: "(quote hello)"
    self assert: (result class =:= SchemeSymbol)

  // --- Define and lookup ---

  testDefine =>
    reader := SchemeReader new
    ev     := SchemeEval new
    env    := ev defaultEnv
    ev eval: (reader read: "(define x 10)") in: env
    self assert: (ev eval: (reader read: "x") in: env) equals: 10

  // --- Lambda and application ---

  testLambdaApply =>
    self assert: (self eval: "((lambda (x) (* x x)) 5)") equals: 25

  testLambdaMultiParam =>
    self assert: (self eval: "((lambda (x y) (+ x y)) 3 4)") equals: 7

  // --- If ---

  testIfTrue =>
    self assert: (self eval: "(if #t 1 2)") equals: 1

  testIfFalse =>
    self assert: (self eval: "(if #f 1 2)") equals: 2

  testIfNoElse =>
    self assert: (self eval: "(if #f 1)") isNil

  // --- Cond ---

  testCond =>
    self assert: (self eval: "(cond (#f 1) (#t 2) (else 3))") equals: 2

  testCondElse =>
    self assert: (self eval: "(cond (#f 1) (else 99))") equals: 99

  // --- And / Or ---

  testAndAllTrue =>
    self assert: (self eval: "(and 1 2 3)") equals: 3

  testAndShortCircuit =>
    self assert: (self eval: "(and #f 2)") equals: false

  testOrFirstTrue =>
    self assert: (self eval: "(or 1 2)") equals: 1

  testOrAllFalse =>
    self assert: (self eval: "(or #f #f)") equals: false

  // --- Let ---

  testLet =>
    self assert: (self eval: "(let ((x 3) (y 4)) (+ x y))") equals: 7

  // --- Printer ---

  testEvalString =>
    self assert: (self eval: """hello""") equals: "hello"

  testPrintString =>
    self assert: (self evalStr: """hello""") equals: """hello"""

  testPrintInt =>
    self assert: (self evalStr: "42") equals: "42"

  testPrintTrue =>
    self assert: (self evalStr: "#t") equals: "#t"

  testPrintFalse =>
    self assert: (self evalStr: "#f") equals: "#f"

  testPrintNil =>
    printer := SchemePrinter new
    self assert: (printer print: nil) equals: "()"

  testPrintList =>
    self assert: (self evalStr: "(list 1 2 3)") equals: "(1 2 3)"

  // --- Closures ---

  testClosure =>
    reader := SchemeReader new
    ev     := SchemeEval new
    env    := ev defaultEnv
    ev eval: (reader read: "(define make-adder (lambda (n) (lambda (x) (+ n x))))") in: env
    ev eval: (reader read: "(define add5 (make-adder 5))") in: env
    self assert: (ev eval: (reader read: "(add5 10)") in: env) equals: 15

  // --- Error handling ---

  testNonProcedureError =>
    result := [self eval: "(1 + 2)"] on: Error do: [:e | e message]
    self assert: result equals: "Not a procedure: 1"

  testNonProcedureErrorInteger =>
    result := [self eval: "(42 1 2)"] on: Error do: [:e | e message]
    self assert: result equals: "Not a procedure: 42"

  // --- Recursion ---

  testFactorial =>
    reader := SchemeReader new
    ev     := SchemeEval new
    env    := ev defaultEnv
    ev eval: (reader read: "(define fact (lambda (n) (if (= n 0) 1 (* n (fact (- n 1))))))") in: env
    self assert: (ev eval: (reader read: "(fact 5)") in: env) equals: 120
