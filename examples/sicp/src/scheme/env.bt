// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

/// SchemeEnv — mutable lexical environment for the Scheme interpreter.
///
/// Each environment frame is a live Beamtalk Actor holding a `Dictionary`
/// of name→value bindings and an optional parent reference. Because actors
/// own their state, `define:value:` persists across calls without threading
/// an updated environment through every expression — a natural fit for
/// Scheme's mutable top-level environment.
///
/// Environments form a chain: global (built-ins) ← top-level defines
/// ← lambda frame ← nested frames. `lookup:` walks the chain automatically.
///
/// ## Examples
/// ```beamtalk
/// env := SchemeEnv spawnWith: #{#bindings => #{}, #parent => nil}
/// env define: "x" value: 42
/// env lookup: "x"    // => 42
/// ```
Actor subclass: SchemeEnv
  state: bindings = #{}
  state: parent   = nil

  /// Look up `name` in this frame, then walk parent frames until found.
  /// Raises an error if the name is unbound in the entire chain, or if the
  /// parent chain exceeds 1000 frames (cycle guard).
  ///
  /// ## Examples
  /// ```beamtalk
  /// env lookup: "x"    // => 42 (if x was defined)
  /// env lookup: "z"    // raises "Unbound variable: z"
  /// ```
  lookup: name =>
    self lookup: name depth: 0

  lookup: name depth: depth =>
    (depth > 1000) ifTrue: [^self error: "Environment chain exceeded maximum depth (cycle detected?)"]
    (self.bindings includesKey: name) ifTrue: [^self.bindings at: name]
    self.parent notNil ifTrue: [^(self.parent lookup: name depth: depth +1)]
    self error: "Unbound variable: " ++ name

  /// Bind or rebind `name` to `val` in this frame.
  ///
  /// ## Examples
  /// ```beamtalk
  /// env define: "x" value: 10
  /// env lookup: "x"    // => 10
  /// ```
  define: name value: val =>
    self.bindings := self.bindings at: name put: val
    nil

  /// Set this frame's parent environment (used during construction).
  /// Raises an error if `p` is `self` to prevent self-parent loops.
  setParent: p =>
    (p =:= self) ifTrue: [^self error: "Cycle detected: environment cannot be its own parent"]
    self.parent := p

  /// Create a child environment that binds each name in `params` to the
  /// corresponding value in `vals`, with `self` as parent. Used by lambda
  /// application to build a new call frame.
  ///
  /// ## Examples
  /// ```beamtalk
  /// child := env extend: #("x", "y") values: #(3, 4)
  /// child lookup: "x"   // => 3
  /// child lookup: "y"   // => 4
  /// ```
  extend: params values: vals =>
    (params size =:= vals size) ifFalse: [
      ^self error: "Arity mismatch: expected " ++ params size printString
                   ++ ", got " ++ vals size printString]
    // zip: returns #{"key" => param, "value" => val} maps
    newBindings := (params zip: vals) inject: #{} into: [:d :pair |
      d at: (pair at: "key") put: (pair at: "value")]
    SchemeEnv spawnWith: #{#bindings => newBindings, #parent => self}
