// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

/// SchemeEnv — mutable lexical environment for the Scheme interpreter.
///
/// Each environment frame is a live Beamtalk Actor holding a `Dictionary`
/// of name→value bindings and an optional parent reference. Because actors
/// own their state, `define:value:` persists across calls without threading
/// an updated environment through every expression — a natural fit for
/// Scheme's mutable top-level environment.
///
/// Environments form a chain: global (built-ins) ← top-level defines
/// ← lambda frame ← nested frames. `lookup:` walks the chain automatically.
///
/// ## Examples
/// ```beamtalk
/// env := SchemeEnv spawnWith: #{#bindings => #{}, #parent => nil}
/// (env define: "x" value: 42) await
/// (env lookup: "x") await    // => 42
/// ```
Actor subclass: SchemeEnv
  state: bindings = #{}
  state: parent   = nil

  /// Look up `name` in this frame, then walk parent frames until found.
  /// Raises an error if the name is unbound in the entire chain.
  ///
  /// ## Examples
  /// ```beamtalk
  /// (env lookup: "x") await    // => 42 (if x was defined)
  /// (env lookup: "z") await    // raises "Unbound variable: z"
  /// ```
  lookup: name =>
    val := self.bindings at: name ifAbsent: [nil]
    val notNil ifTrue: [^val]
    self.parent notNil ifTrue: [^(self.parent lookup: name) await]
    self error: "Unbound variable: " ++ name

  /// Bind or rebind `name` to `val` in this frame.
  ///
  /// ## Examples
  /// ```beamtalk
  /// (env define: "x" value: 10) await
  /// (env lookup: "x") await    // => 10
  /// ```
  define: name value: val =>
    self.bindings := self.bindings at: name put: val
    nil

  /// Set this frame's parent environment (used during construction).
  setParent: p =>
    self.parent := p

  /// Create a child environment that binds each name in `params` to the
  /// corresponding value in `vals`, with `self` as parent. Used by lambda
  /// application to build a new call frame.
  ///
  /// ## Examples
  /// ```beamtalk
  /// child := (env extend: #("x" "y") values: #(3 4)) await
  /// (child lookup: "x") await   // => 3
  /// (child lookup: "y") await   // => 4
  /// ```
  extend: params values: vals =>
    (params size =:= vals size) ifFalse: [
      ^self error: "Arity mismatch: expected " ++ params size printString
                   ++ ", got " ++ vals size printString]
    newBindings := (params zip: vals) inject: #{} into: [:d :pair |
      d at: (pair at: "key") put: (pair at: "value")]
    SchemeEnv spawnWith: #{#bindings => newBindings, #parent => self}
