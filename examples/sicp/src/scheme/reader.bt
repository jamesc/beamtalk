// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

/// SchemeReader — tokenises and parses s-expression strings into Beamtalk values.
///
/// Uses a functional char-list approach: each internal parse method receives a
/// List of single-character String values (from `String>>asList`) and returns a
/// 2-element `#(parsedValue, remainingChars)` pair. The public `read:` entry
/// point extracts just the value.
///
/// Supported syntax:
/// - **atoms** — symbols, integers, booleans (`#t` / `#f`), strings (`"..."`)
/// - **lists** — `(elem ...)` including nested lists
///
/// String escaping: a doubled delimiter `""` produces a literal `"` character.
///
/// ## Examples
/// ```beamtalk
/// reader := SchemeReader new
/// reader read: "(+ 1 2)"    // => #(SchemeSymbol(+), 1, 2)
/// reader read: "42"         // => 42
/// reader read: "#t"         // => true
/// reader read: "()"         // => #()
/// ```
Object subclass: SchemeReader

  /// Parse a Scheme expression string and return its AST value.
  ///
  /// ## Examples
  /// ```beamtalk
  /// SchemeReader new read: "(* 6 7)"   // => #(SchemeSymbol(*), 6, 7)
  /// SchemeReader new read: "hello"     // => SchemeSymbol("hello")
  /// ```
  read: str =>
    chars := str asList
    pair  := self parseExpr: (self dropWs: chars)
    rest  := self dropWs: pair last
    rest isEmpty ifFalse: [^self error: "Unexpected trailing input"]
    pair first

  /// Return true if `ch` is a whitespace character (space, newline, tab, carriage return).
  isWs: ch =>
    #(" ", "\n", "\t", "\r") includes: ch

  /// Drop leading whitespace characters from a char list.
  dropWs: chars =>
    chars isEmpty ifTrue: [^chars]
    (self isWs: chars first) ifFalse: [^chars]
    self dropWs: chars rest

  /// Wrap `val` and `chars` into a 2-element `#(val, remainingChars)` pair.
  pairOf: val rest: chars =>
    (#() add: val) add: chars

  /// Return true if `ch` is a token delimiter (whitespace, `(`, or `)`).
  isDelim: ch =>
    (self isWs: ch) or: [#("(", ")") includes: ch]

  /// Dispatch to the appropriate sub-parser based on the leading character.
  ///
  /// - `(` → list
  /// - `#` → boolean
  /// - digit → integer
  /// - `"` → string
  /// - anything else → symbol
  parseExpr: chars =>
    chars isEmpty ifTrue: [^self error: "Unexpected end of input"]
    ch := chars first
    (ch =:= "(") ifTrue: [^self parseListElems: chars rest]
    (ch =:= "#") ifTrue: [^self parseBool: chars rest]
    ch isDigit        ifTrue: [^self parseNum: chars acc: ""]
    (ch =:= """")     ifTrue: [^self parseString: chars rest acc: ""]
    self parseSym: chars acc: ""

  /// Parse list elements after the opening `(` has been consumed.
  /// Recursively parses elements until `)` is reached.
  parseListElems: chars =>
    trimmed := self dropWs: chars
    trimmed isEmpty ifTrue: [^self error: "Missing ')'"]
    (trimmed first =:= ")") ifTrue: [^self pairOf: #() rest: trimmed rest]
    headPair := self parseExpr: trimmed
    head     := headPair first
    tailPair := self parseListElems: (self dropWs: headPair last)
    tail     := tailPair first
    self pairOf: ((#() add: head) ++ tail) rest: tailPair last

  /// Parse `#t` or `#f`; `chars` is positioned after the `#`.
  ///
  /// ## Examples
  /// ```beamtalk
  /// SchemeReader new read: "#t"   // => true
  /// SchemeReader new read: "#f"   // => false
  /// ```
  parseBool: chars =>
    chars isEmpty ifTrue: [^self error: "Unexpected '#'"]
    (chars first =:= "t") ifTrue: [^self pairOf: true  rest: chars rest]
    (chars first =:= "f") ifTrue: [^self pairOf: false rest: chars rest]
    self error: "Unknown # token"

  /// Parse an integer by accumulating digit characters until a delimiter.
  ///
  /// ## Examples
  /// ```beamtalk
  /// SchemeReader new read: "42"    // => 42
  /// ```
  parseNum: chars acc: acc =>
    (chars isEmpty or: [self isDelim: chars first]) ifTrue: [
      ^self pairOf: acc asInteger rest: chars]
    self parseNum: chars rest acc: acc ++ chars first

  /// Parse a string literal; `chars` is positioned after the opening `"`.
  /// A doubled delimiter `""` represents a single literal `"` character.
  ///
  /// ## Examples
  /// ```beamtalk
  /// SchemeReader new read: """hello"""     // => "hello"
  /// ```
  parseString: chars acc: acc =>
    chars isEmpty ifTrue: [^self error: "Unterminated string literal"]
    (chars first =:= """") ifTrue: [
      (chars rest isEmpty not and: [chars rest first =:= """"]) ifTrue: [
        ^self parseString: chars rest rest acc: acc ++ """"]
      ^self pairOf: acc rest: chars rest]
    self parseString: chars rest acc: acc ++ chars first

  /// Parse a symbol by accumulating non-delimiter characters.
  ///
  /// ## Examples
  /// ```beamtalk
  /// SchemeReader new read: "define"   // => SchemeSymbol("define")
  /// SchemeReader new read: "+"        // => SchemeSymbol("+")
  /// ```
  parseSym: chars acc: acc =>
    (chars isEmpty or: [self isDelim: chars first]) ifTrue: [
      ^self pairOf: (SchemeSymbol withName: acc) rest: chars]
    self parseSym: chars rest acc: acc ++ chars first
