// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

// =============================================================================
// ProtoObject Example: Transparent Proxy Pattern
// =============================================================================
//
// This example demonstrates ProtoObject's fundamental methods working together
// to implement a transparent proxy that forwards unknown messages to a target.
//
// ## What This Demonstrates
//
// 1. **ProtoObject.class** - Every object can report its class
// 2. **ProtoObject.doesNotUnderstand:args:** - Catch unknown messages
// 3. **ProtoObject.perform:withArguments:** - Dynamic message dispatch
// 4. **ProtoObject.== and /=** - Identity comparison
// 5. **Transparent proxy pattern** - Proxy is indistinguishable from target
//
// ## How to Run
//
// ```bash
// $ cargo run -- repl
// > :load examples/protoobject_proxy.bt
// > :load tests/e2e/fixtures/counter.bt
// 
// # Create a counter and increment it
// > counter := Counter spawn
// > counter increment
// => 1
//
// # Create a proxy and forward messages through it
// > proxy := TransparentProxy spawn
// > proxy setTarget: counter
// > proxy increment              # Forwarded to counter!
// => 2
//
// # Verify the counter was incremented
// > counter getValue
// => 2
//
// # The proxy looks just like the real object
// > counter class
// => Counter
// > proxy targetClass
// => Counter
// ```
//
// ## Key Insight: Auto-Await in REPL
//
// Notice that both `counter increment` and `proxy increment` return the same
// thing: `=> 2`. With sync-by-default dispatch, actor sends return values
// directly (via gen_server:call), making the proxy completely transparent.
//
// =============================================================================

/// TransparentProxy - Forwards all unknown messages to a target object
///
/// This demonstrates ProtoObject's doesNotUnderstand:args: and perform:withArguments:
/// working together to create a proxy that's indistinguishable from the target.
Actor subclass: TransparentProxy
  state: target = nil
  
  // Set the target object that receives forwarded messages
  setTarget: newTarget =>
    self.target := newTarget
  
  // Get the class of the target (for debugging)
  targetClass =>
    self.target class
  
  // ProtoObject's doesNotUnderstand:args: catches unknown messages
  // This is called when TransparentProxy receives a message it doesn't have
  doesNotUnderstand: selector args: arguments =>
    // Use ProtoObject's perform:withArguments: for dynamic dispatch
    // This sends the message to the target as if we called it directly
    self.target perform: selector withArguments: arguments

// =============================================================================
// What Happens When You Call: proxy increment
// =============================================================================
//
// 1. Message Send: User types `proxy increment`
//
// 2. Compiler Generates:
//    ```erlang
//    gen_server:call(Pid, {"increment", []})  % Sync call, blocks until result
//    ```
//
// 3. Runtime Dispatch:
//    - TransparentProxy's gen_server receives {"increment", []}
//    - Looks for "increment" in method table → NOT FOUND
//    - Checks for "doesNotUnderstand:args:" → FOUND!
//    - Calls: doesNotUnderstand("increment", [])
//
// 4. doesNotUnderstand Executes:
//    ```beamtalk
//    self.target perform: "increment" withArguments: []
//    ```
//
// 5. perform:withArguments: Generates:
//    ```erlang
//    gen_server:call(TargetPid, {"increment", []})  % Sync call to counter
//    ```
//
// 6. Counter Receives Message:
//    - Counter's "increment" method executes
//    - Counter's value increments: 1 → 2
//    - Counter returns result (2) to TransparentProxy
//
// 7. TransparentProxy Returns:
//    - doesNotUnderstand returns 2 (the counter's result)
//    - gen_server:call returns 2 to the caller
//
// 8. User Sees:
//    ```beamtalk
//    > proxy increment
//    => 2          # Exactly like calling counter directly!
//    ```
//
// =============================================================================
// Why This Works: Sync-by-Default Dispatch
// =============================================================================
//
// Both calls look IDENTICAL to the user:
//
// | User Action        | Generated Code | Runtime             | REPL Shows |
// |--------------------|----------------|---------------------|------------|
// | counter increment  | Integer        | Executes increment  | => 2       |
// | proxy increment    | Integer        | Forwards to counter | => 2       |
//
// The proxy is completely transparent because:
// 1. Both return the value directly (sync gen_server:call)
// 2. REPL displays the result value
// 3. User sees identical behavior for direct and proxied calls
//
// This is the power of ProtoObject's doesNotUnderstand:args: and
// perform:withArguments: - you can intercept and forward messages
// while maintaining complete transparency.
//
// =============================================================================
// Testing ProtoObject Methods Directly
// =============================================================================
//
// You can also test ProtoObject methods on primitives:
//
// ```beamtalk
// # class works on all types
// > 42 class
// => Integer
//
// > "hello" class
// => String
//
// > true class
// => True
//
// # Identity comparison
// > 42 == 42
// => true
//
// > 42 /= 43
// => true
//
// > "hello" == "hello"
// => true
// ```
//
// ProtoObject.class uses pattern matching in the compiler:
//
// ```erlang
// case Receiver of
//   <I> when is_integer(I) -> 'Integer'
//   <S> when is_binary(S) -> 'String'
//   <'true'> when 'true' -> 'True'
//   <'false'> when 'true' -> 'False'
//   <'nil'> when 'true' -> 'Nil'
//   <Obj> when 'true' -> element(2, Obj)  % Extract class from actor record
// end
// ```
//
// This allows every object - primitive or actor - to respond to the class message.
