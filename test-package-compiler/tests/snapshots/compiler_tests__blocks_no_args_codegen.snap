---
source: test-package-compiler/tests/compiler_tests.rs
expression: core_erlang
---
module 'blocks_no_args' ['start_link'/1, 'init'/1, 'handle_cast'/2, 'handle_call'/3, 'code_change'/3, 'terminate'/2, 'dispatch'/4, 'safe_dispatch'/3, 'method_table'/0, 'has_method'/1, 'spawn'/0, 'spawn'/1, 'new'/0, 'new'/1]
  attributes ['behaviour' = ['gen_server']]

'start_link'/1 = fun (InitArgs) ->
    call 'gen_server':'start_link'('blocks_no_args', InitArgs, [])


'spawn'/0 = fun () ->
    case call 'gen_server':'start_link'('blocks_no_args', ~{}~, []) of
        <{'ok', Pid}> when 'true' ->
            {'beamtalk_object', 'BlocksNoArgs', 'blocks_no_args', Pid}
        <{'error', Reason}> when 'true' ->
            call 'erlang':'error'({'spawn_failed', Reason})
    end


'spawn'/1 = fun (InitArgs) ->
    case call 'gen_server':'start_link'('blocks_no_args', InitArgs, []) of
        <{'ok', Pid}> when 'true' ->
            {'beamtalk_object', 'BlocksNoArgs', 'blocks_no_args', Pid}
        <{'error', Reason}> when 'true' ->
            call 'erlang':'error'({'spawn_failed', Reason})
    end


'new'/0 = fun () ->
    let Error0 = call 'beamtalk_error':'new'('instantiation_error', 'Actor') in
    let Error1 = call 'beamtalk_error':'with_selector'(Error0, 'new') in
    let Error2 = call 'beamtalk_error':'with_hint'(Error1, #{#<85>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']])}#) in
    call 'erlang':'error'(Error2)

'new'/1 = fun (_InitArgs) ->
    let Error0 = call 'beamtalk_error':'new'('instantiation_error', 'Actor') in
    let Error1 = call 'beamtalk_error':'with_selector'(Error0, 'new:') in
    let Error2 = call 'beamtalk_error':'with_hint'(Error1, #{#<85>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<87>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<104>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']])}#) in
    call 'erlang':'error'(Error2)

'init'/1 = fun (InitArgs) ->
    let DefaultState = ~{
        '__class__' => 'BlocksNoArgs',
        '__class_mod__' => 'blocks_no_args',
        '__methods__' => call 'blocks_no_args':'method_table'()
        , 'outer' => 10
    }~
    in let FinalState = call 'maps':'merge'(DefaultState, InitArgs)
    in {'ok', FinalState}


'handle_cast'/2 = fun (Msg, State) ->
    case Msg of
        <{Selector, Args, FuturePid}> when 'true' ->
            case call 'blocks_no_args':'safe_dispatch'(Selector, Args, State) of
                <{'reply', Result, NewState}> when 'true' ->
                    let _Ignored = call 'erlang':'!'(FuturePid, {'resolve', Result})
                    in {'noreply', NewState}
                <{'error', Error, NewState}> when 'true' ->
                    let _Ignored = call 'erlang':'!'(FuturePid, {'reject', Error})
                    in {'noreply', NewState}
            end
    end


'handle_call'/3 = fun (Msg, _From, State) ->
    case Msg of
        <{Selector, Args}> when 'true' ->
            case call 'blocks_no_args':'safe_dispatch'(Selector, Args, State) of
                <{'reply', Result, NewState}> when 'true' ->
                    {'reply', {'ok', Result}, NewState}
                <{'error', Error, NewState}> when 'true' ->
                    {'reply', {'error', Error}, NewState}
            end
    end


'code_change'/3 = fun (_OldVsn, State, _Extra) ->
    %% TODO: Add state migration logic
    {'ok', State}


'terminate'/2 = fun (Reason, State) ->
    %% Call terminate method if defined (Flavors pattern)
    let Self = call 'beamtalk_actor':'make_self'(State) in
    case call 'blocks_no_args':'dispatch'('terminate', [Reason], Self, State) of
        <{'reply', _TermResult, _TermState}> when 'true' -> 'ok'
        <{'error', _TermError, _TermState2}> when 'true' -> 'ok'
        <_TermOther> when 'true' -> 'ok'
    end


'safe_dispatch'/3 = fun (Selector, Args, State) ->
    let Self = call 'beamtalk_actor':'make_self'(State) in
    try call 'blocks_no_args':'dispatch'(Selector, Args, Self, State)
    of Result -> Result
    catch <Type, Error, _Stacktrace> -> {'error', {Type, Error}, State}


'dispatch'/4 = fun (Selector, Args, Self, State) ->
    case Selector of
        <'noArgs'> when 'true' ->
            let _Result = 42 in {'reply', _Result, State}
        <'captureBlock'> when 'true' ->
            let _Result = call 'erlang':'+'(call 'maps':'get'('outer', State), 5) in {'reply', _Result, State}
        <'condition'> when 'true' ->
            let _Result = call 'erlang':'>'(call 'maps':'get'('counter', State), 0) in {'reply', _Result, State}
        <'block1'> when 'true' ->
            let _Result = 1 in {'reply', _Result, State}
        <'block2'> when 'true' ->
            let _Result = 2 in {'reply', _Result, State}
        <'block3'> when 'true' ->
            let _Result = 3 in {'reply', _Result, State}
        <'class'> when 'true' ->
            case Args of
                <[]> when 'true' ->
                    let ClassName = call 'maps':'get'('__class__', State) in
                    {'reply', ClassName, State}
                <_> when 'true' -> {'reply', {'error', 'bad_arity'}, State}
            end
        <'respondsTo:'> when 'true' ->
            case Args of
                <[Selector]> when 'true' ->
                    let Methods = call 'maps':'get'('__methods__', State) in
                    let Result = call 'maps':'is_key'(Selector, Methods) in
                    {'reply', Result, State}
                <_> when 'true' -> {'reply', {'error', 'bad_arity'}, State}
            end
        <'instVarNames'> when 'true' ->
            case Args of
                <[]> when 'true' ->
                    %% Filter out internal fields starting with '__'
                    let AllFields = call 'maps':'keys'(State) in
                    let FilterFn = fun (Key) ->
                        case Key of
                            <'__class__'> when 'true' -> 'false'
                            <'__class_mod__'> when 'true' -> 'false'
                            <'__methods__'> when 'true' -> 'false'
                            <'__registry_pid__'> when 'true' -> 'false'
                            <_> when 'true' -> 'true'
                        end
                    in
                    let UserFields = call 'lists':'filter'(FilterFn, AllFields) in
                    {'reply', UserFields, State}
                <_> when 'true' -> {'reply', {'error', 'bad_arity'}, State}
            end
        <'instVarAt:'> when 'true' ->
            case Args of
                <[FieldName]> when 'true' ->
                    case call 'maps':'is_key'(FieldName, State) of
                        <'true'> when 'true' ->
                            let Value = call 'maps':'get'(FieldName, State) in
                            {'reply', Value, State}
                        <'false'> when 'true' ->
                            {'reply', {'error', 'field_not_found'}, State}
                        end
                    <_> when 'true' -> {'reply', {'error', 'bad_arity'}, State}
                end
            <'instVarAt:put:'> when 'true' ->
                case Args of
                    <[FieldName, Value]> when 'true' ->
                        case call 'maps':'is_key'(FieldName, State) of
                            <'true'> when 'true' ->
                                let NewState = call 'maps':'put'(FieldName, Value, State) in
                                {'reply', Value, NewState}
                            <'false'> when 'true' ->
                                {'reply', {'error', 'field_not_found'}, State}
                            end
                        <_> when 'true' -> {'reply', {'error', 'bad_arity'}, State}
                    end
                <OtherSelector> when 'true' ->
                    %% Try doesNotUnderstand:args: fallback (BT-29)
                    let DnuSelector = 'doesNotUnderstand:args:' in
                    let Methods = call 'maps':'get'('__methods__', State) in
                    case call 'maps':'is_key'(DnuSelector, Methods) of
                        <'true'> when 'true' ->
                            %% Call doesNotUnderstand:args: with [Selector, Args]
                            call 'blocks_no_args':'dispatch'(DnuSelector, [OtherSelector, Args], Self, State)
                        <'false'> when 'true' ->
                            %% No DNU handler - return #beamtalk_error{} record
                            let ClassName = call 'maps':'get'('__class__', State) in
                            let Error0 = call 'beamtalk_error':'new'('does_not_understand', ClassName) in
                            let Error1 = call 'beamtalk_error':'with_selector'(Error0, OtherSelector) in
                            let HintMsg = #{#<67>(8,1,'integer',['unsigned'|['big']]),#<104>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<107>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<39>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<84>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<39>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<102>(8,1,'integer',['unsigned'|['big']]),#<121>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<104>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<120>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']])}# in
                            let Error = call 'beamtalk_error':'with_hint'(Error1, HintMsg) in
                            {'error', Error, State}
                    end
            end


'method_table'/0 = fun () ->
            ~{'noArgs' => 0, 'captureBlock' => 0, 'condition' => 0, 'block1' => 0, 'block2' => 0, 'block3' => 0, 'class' => 0, 'respondsTo:' => 1, 'instVarNames' => 0, 'instVarAt:' => 1, 'instVarAt:put:' => 2, 'perform:' => 1, 'perform:withArguments:' => 2}~


'has_method'/1 = fun (Selector) ->
            call 'lists':'member'(Selector, ['noArgs', 'captureBlock', 'condition', 'block1', 'block2', 'block3', 'class', 'respondsTo:', 'instVarNames', 'instVarAt:', 'instVarAt:put:', 'perform:', 'perform:withArguments:'])

end
