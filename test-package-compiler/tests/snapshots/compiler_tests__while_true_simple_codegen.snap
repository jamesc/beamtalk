---
source: test-package-compiler/tests/compiler_tests.rs
expression: core_erlang
---
module 'while_true_simple' ['start_link'/1, 'start_link'/2, 'init'/1, 'handle_cast'/2, 'handle_call'/3, 'code_change'/3, 'terminate'/2, 'dispatch'/4, 'safe_dispatch'/3, 'method_table'/0, 'has_method'/1, 'spawn'/0, 'spawn'/1, 'new'/0, 'new'/1, 'superclass'/0]
  attributes ['behaviour' = ['gen_server']]

'start_link'/1 = fun (InitArgs) ->
    call 'gen_server':'start_link'('while_true_simple', InitArgs, [])


'start_link'/2 = fun (ServerName, InitArgs) ->
    call 'gen_server':'start_link'(ServerName, 'while_true_simple', InitArgs, [])


'spawn'/0 = fun () ->
    case call 'gen_server':'start_link'('while_true_simple', ~{}~, []) of
        <{'ok', Pid}> when 'true' ->
            let _InstReg = try call 'beamtalk_object_instances':'register'('WhileTrueSimple', Pid)
                of _RegOk -> _RegOk
                catch <_RegT, _RegE, _RegS> -> 'ok'
            in
            {'beamtalk_object', 'WhileTrueSimple', 'while_true_simple', Pid}
        <{'error', Reason}> when 'true' ->
            let SpawnErr0 = call 'beamtalk_error':'new'('instantiation_error', 'WhileTrueSimple') in
            let SpawnErr1 = call 'beamtalk_error':'with_selector'(SpawnErr0, 'spawn') in
            call 'beamtalk_error':'raise'(SpawnErr1)
    end


'spawn'/1 = fun (InitArgs) ->
    case call 'erlang':'is_map'(InitArgs) of
        <'false'> when 'true' ->
            let TypeErr0 = call 'beamtalk_error':'new'('type_error', 'WhileTrueSimple') in
            let TypeErr1 = call 'beamtalk_error':'with_selector'(TypeErr0, 'spawnWith:') in
            let TypeErr2 = call 'beamtalk_error':'with_hint'(TypeErr1, #{#<115>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<87>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<104>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<120>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<68>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<121>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']])}#) in
            call 'beamtalk_error':'raise'(TypeErr2)
        <'true'> when 'true' ->
            case call 'gen_server':'start_link'('while_true_simple', InitArgs, []) of
                <{'ok', Pid}> when 'true' ->
                    let _InstReg = try call 'beamtalk_object_instances':'register'('WhileTrueSimple', Pid)
                        of _RegOk -> _RegOk
                        catch <_RegT, _RegE, _RegS> -> 'ok'
                    in
                    {'beamtalk_object', 'WhileTrueSimple', 'while_true_simple', Pid}
                <{'error', Reason}> when 'true' ->
                    let SpawnErr0 = call 'beamtalk_error':'new'('instantiation_error', 'WhileTrueSimple') in
                    let SpawnErr1 = call 'beamtalk_error':'with_selector'(SpawnErr0, 'spawnWith:') in
                    call 'beamtalk_error':'raise'(SpawnErr1)
            end
    end


'new'/0 = fun () ->
    let Error0 = call 'beamtalk_error':'new'('instantiation_error', 'Actor') in
    let Error1 = call 'beamtalk_error':'with_selector'(Error0, 'new') in
    let Error2 = call 'beamtalk_error':'with_hint'(Error1, #{#<85>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']])}#) in
    call 'beamtalk_error':'raise'(Error2)

'new'/1 = fun (_InitArgs) ->
    let Error0 = call 'beamtalk_error':'new'('instantiation_error', 'Actor') in
    let Error1 = call 'beamtalk_error':'with_selector'(Error0, 'new:') in
    let Error2 = call 'beamtalk_error':'with_hint'(Error1, #{#<85>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<87>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<104>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']])}#) in
    call 'beamtalk_error':'raise'(Error2)

'superclass'/0 = fun () -> 'nil'


'init'/1 = fun (InitArgs) ->
    let DefaultState = ~{
        '$beamtalk_class' => 'WhileTrueSimple',
        '__class_mod__' => 'while_true_simple',
        '__methods__' => call 'while_true_simple':'method_table'()
    }~
    in let FinalState = call 'maps':'merge'(DefaultState, InitArgs)
    in {'ok', FinalState}


'handle_cast'/2 = fun (Msg, State) ->
    case Msg of
        <{'cast', CastSelector, CastArgs}> when 'true' ->
            case call 'while_true_simple':'safe_dispatch'(CastSelector, CastArgs, State) of
                <{'reply', _CastResult, CastNewState}> when 'true' ->
                    {'noreply', CastNewState}
                <{'error', _CastError, _CastState}> when 'true' ->
                    {'noreply', State}
            end
        <{Selector, Args, FuturePid}> when 'true' ->
            let _ = call 'erlang':'put'('$bt_future_pid', FuturePid)
            in case call 'while_true_simple':'safe_dispatch'(Selector, Args, State) of
                <{'reply', Result, NewState}> when 'true' ->
                    let _Ignored = call 'erlang':'!'(FuturePid, {'resolve', Result})
                    in {'noreply', NewState}
                <{'error', Error, NewState}> when 'true' ->
                    let _Ignored = call 'erlang':'!'(FuturePid, {'reject', Error})
                    in {'noreply', NewState}
            end
    end


'handle_call'/3 = fun (Msg, _From, State) ->
    case Msg of
        <{Selector, Args}> when 'true' ->
            case call 'while_true_simple':'safe_dispatch'(Selector, Args, State) of
                <{'reply', Result, NewState}> when 'true' ->
                    {'reply', {'ok', Result}, NewState}
                <{'error', Error, NewState}> when 'true' ->
                    {'reply', {'error', Error}, NewState}
            end
    end


'code_change'/3 = fun (OldVsn, State, Extra) ->
    call 'beamtalk_hot_reload':'code_change'(OldVsn, State, Extra)


'terminate'/2 = fun (Reason, State) ->
    %% Call terminate method if defined
    let Self = call 'beamtalk_actor':'make_self'(State) in
    case call 'while_true_simple':'dispatch'('terminate', [Reason], Self, State) of
        <{'reply', _TermResult, _TermState}> when 'true' -> 'ok'
        <{'error', _TermError, _TermState2}> when 'true' -> 'ok'
        <_TermOther> when 'true' -> 'ok'
    end


'safe_dispatch'/3 = fun (Selector, Args, State) ->
    let Self = call 'beamtalk_actor':'make_self'(State) in
    try call 'while_true_simple':'dispatch'(Selector, Args, Self, State)
    of Result -> Result
    catch <Type, Error, _Stacktrace> -> {'error', {Type, Error}, State}


'dispatch'/4 = fun (Selector, Args, Self, State) ->
    case Selector of
        <'test'> when 'true' ->
            let Count = 0 in let _Tuple1 = let _Packed3 = call 'maps':'put'('__local__count', Count, State) in letrec 'while'/1 = fun (StateAcc) -> let Count = call 'maps':'get'('__local__count', StateAcc) in let _CondFun2 = fun (StateAcc) -> call 'erlang':'<'(call 'beamtalk_future':'maybe_await'(Count), call 'beamtalk_future':'maybe_await'(3)) in case apply _CondFun2 (StateAcc) of <'true'> when 'true' -> let _Val4 = call 'erlang':'+'(call 'beamtalk_future':'maybe_await'(Count), call 'beamtalk_future':'maybe_await'(1)) in let StateAcc1 = call 'maps':'put'('__local__count', _Val4, StateAcc) in  apply 'while'/1 (StateAcc1) <'false'> when 'true' -> {'nil', StateAcc} end in apply 'while'/1 (_Packed3) in let State1 = call 'erlang':'element'(2, _Tuple1) in let Count = call 'maps':'get'('__local__count', State1) in let _Result = Count in {'reply', _Result, State1}
        <'testLocal'> when 'true' ->
            let X = 0 in let _Tuple5 = let _Packed7 = call 'maps':'put'('__local__x', X, State) in letrec 'while'/1 = fun (StateAcc) -> let X = call 'maps':'get'('__local__x', StateAcc) in let _CondFun6 = fun (StateAcc) -> call 'erlang':'<'(call 'beamtalk_future':'maybe_await'(X), call 'beamtalk_future':'maybe_await'(5)) in case apply _CondFun6 (StateAcc) of <'true'> when 'true' -> let _Val8 = call 'erlang':'+'(call 'beamtalk_future':'maybe_await'(X), call 'beamtalk_future':'maybe_await'(1)) in let StateAcc1 = call 'maps':'put'('__local__x', _Val8, StateAcc) in  apply 'while'/1 (StateAcc1) <'false'> when 'true' -> {'nil', StateAcc} end in apply 'while'/1 (_Packed7) in let State1 = call 'erlang':'element'(2, _Tuple5) in let X = call 'maps':'get'('__local__x', State1) in let _Result = X in {'reply', _Result, State1}
        <'testBlockParam'> when 'true' ->
            let Result = let _Fun9 = fun (_x10) -> let _x10 = let _Packed12 = call 'maps':'put'('__local__x', _x10, State) in letrec 'while'/1 = fun (StateAcc) -> let X = call 'maps':'get'('__local__x', StateAcc) in let _CondFun11 = fun (StateAcc) -> call 'erlang':'<'(call 'beamtalk_future':'maybe_await'(X), call 'beamtalk_future':'maybe_await'(5)) in case apply _CondFun11 (StateAcc) of <'true'> when 'true' -> let _Val13 = call 'erlang':'+'(call 'beamtalk_future':'maybe_await'(X), call 'beamtalk_future':'maybe_await'(1)) in let StateAcc1 = call 'maps':'put'('__local__x', _Val13, StateAcc) in  apply 'while'/1 (StateAcc1) <'false'> when 'true' -> {'nil', StateAcc} end in apply 'while'/1 (_Packed12) in _x10 in apply _Fun9 (0) in let _Result = Result in {'reply', _Result, State}
        <'testBlockParamWhileFalse'> when 'true' ->
            let Result = let _Fun14 = fun (_n15) -> let _n15 = let _Packed17 = call 'maps':'put'('__local__n', _n15, State) in letrec 'while'/1 = fun (StateAcc) -> let N = call 'maps':'get'('__local__n', StateAcc) in let _CondFun16 = fun (StateAcc) -> call 'erlang':'=:='(call 'beamtalk_future':'maybe_await'(N), call 'beamtalk_future':'maybe_await'(0)) in case apply _CondFun16 (StateAcc) of <'false'> when 'true' -> let _Val18 = call 'erlang':'-'(call 'beamtalk_future':'maybe_await'(N), call 'beamtalk_future':'maybe_await'(1)) in let StateAcc1 = call 'maps':'put'('__local__n', _Val18, StateAcc) in  apply 'while'/1 (StateAcc1) <'true'> when 'true' -> {'nil', StateAcc} end in apply 'while'/1 (_Packed17) in _n15 in apply _Fun14 (5) in let _Result = Result in {'reply', _Result, State}
        <'testTimesRepeat'> when 'true' ->
            let Counter = 0 in let _Tuple19 = let _Packed21 = call 'maps':'put'('__local__counter', Counter, State) in let _temp20 = 5 in letrec 'repeat'/2 = fun (I, StateAcc) -> let Counter = call 'maps':'get'('__local__counter', StateAcc) in case call 'erlang':'=<'(I, _temp20) of <'true'> when 'true' -> let _Val22 = call 'erlang':'+'(call 'beamtalk_future':'maybe_await'(Counter), call 'beamtalk_future':'maybe_await'(1)) in let StateAcc1 = call 'maps':'put'('__local__counter', _Val22, StateAcc) in  apply 'repeat'/2 (call 'erlang':'+'(I, 1), StateAcc1) <'false'> when 'true' -> {'nil', StateAcc} end in apply 'repeat'/2 (1, _Packed21) in let State1 = call 'erlang':'element'(2, _Tuple19) in let Counter = call 'maps':'get'('__local__counter', State1) in let _Result = Counter in {'reply', _Result, State1}
        <'testTimesRepeatBlockParam'> when 'true' ->
            let Result = let _Fun23 = fun (_n24) -> let _n24 = let _Packed26 = call 'maps':'put'('__local__n', _n24, State) in let _temp25 = 3 in letrec 'repeat'/2 = fun (I, StateAcc) -> let N = call 'maps':'get'('__local__n', StateAcc) in case call 'erlang':'=<'(I, _temp25) of <'true'> when 'true' -> let _Val27 = call 'erlang':'+'(call 'beamtalk_future':'maybe_await'(N), call 'beamtalk_future':'maybe_await'(10)) in let StateAcc1 = call 'maps':'put'('__local__n', _Val27, StateAcc) in  apply 'repeat'/2 (call 'erlang':'+'(I, 1), StateAcc1) <'false'> when 'true' -> {'nil', StateAcc} end in apply 'repeat'/2 (1, _Packed26) in _n24 in apply _Fun23 (5) in let _Result = Result in {'reply', _Result, State}
        <'testToDo'> when 'true' ->
            let Total = 0 in let _Tuple28 = let _Packed31 = call 'maps':'put'('__local__total', Total, State) in let _temp29 = 1 in let _temp30 = 10 in letrec 'loop'/2 = fun (I, StateAcc) -> let Total = call 'maps':'get'('__local__total', StateAcc) in case call 'erlang':'=<'(I, _temp30) of <'true'> when 'true' -> let _Val32 = call 'erlang':'+'(call 'beamtalk_future':'maybe_await'(Total), call 'beamtalk_future':'maybe_await'(I)) in let StateAcc1 = call 'maps':'put'('__local__total', _Val32, StateAcc) in   apply 'loop'/2 (call 'erlang':'+'(I, 1), StateAcc1) <'false'> when 'true' -> {'nil', StateAcc} end  in apply 'loop'/2 (_temp29, _Packed31) in let State1 = call 'erlang':'element'(2, _Tuple28) in let Total = call 'maps':'get'('__local__total', State1) in let _Result = Total in {'reply', _Result, State1}
        <'testToDoBlockParam'> when 'true' ->
            let Result = let _Fun33 = fun (_x34) -> let Sum = 0 in let Sum = let _Packed37 = call 'maps':'put'('__local__sum', Sum, State) in let _temp35 = _x34 in let _temp36 = 5 in letrec 'loop'/2 = fun (I, StateAcc) -> let Sum = call 'maps':'get'('__local__sum', StateAcc) in case call 'erlang':'=<'(I, _temp36) of <'true'> when 'true' -> let _Val38 = call 'erlang':'+'(call 'beamtalk_future':'maybe_await'(Sum), call 'beamtalk_future':'maybe_await'(I)) in let StateAcc1 = call 'maps':'put'('__local__sum', _Val38, StateAcc) in   apply 'loop'/2 (call 'erlang':'+'(I, 1), StateAcc1) <'false'> when 'true' -> {'nil', StateAcc} end  in apply 'loop'/2 (_temp35, _Packed37) in Sum in apply _Fun33 (1) in let _Result = Result in {'reply', _Result, State}
        <OtherSelector> when 'true' ->
            %% BT-229/ADR 0005: Check extension registry before hierarchy walk
            let ExtLookup = try call 'beamtalk_extensions':'lookup'('WhileTrueSimple', OtherSelector)
                of ExtLookupResult -> ExtLookupResult
                catch <_EType, _EReason, _EStack> -> 'not_found'
            in
            case ExtLookup of
                <{'ok', ExtFun, _ExtOwner}> when 'true' ->
                    let ExtResult = apply ExtFun(Args, Self) in
                    {'reply', ExtResult, State}
                <'not_found'> when 'true' ->
                    %% ADR 0006: Try hierarchy walk before DNU
                    case call 'beamtalk_dispatch':'super'(OtherSelector, Args, Self, State, 'WhileTrueSimple') of
                        <{'reply', InheritedResult, InheritedState}> when 'true' ->
                            {'reply', InheritedResult, InheritedState}
                        <{'error', _DispatchError}> when 'true' ->
                            %% Not in hierarchy - try doesNotUnderstand:args: (BT-29)
                            let DnuSelector = 'doesNotUnderstand:args:' in
                            let Methods = call 'maps':'get'('__methods__', State) in
                            case call 'maps':'is_key'(DnuSelector, Methods) of
                                <'true'> when 'true' ->
                                    call 'while_true_simple':'dispatch'(DnuSelector, [OtherSelector, Args], Self, State)
                                <'false'> when 'true' ->
                                    %% No DNU handler - return #beamtalk_error{} record
                                    let ClassName = call 'maps':'get'('$beamtalk_class', State) in
                                    let Error0 = call 'beamtalk_error':'new'('does_not_understand', ClassName) in
                                    let Error1 = call 'beamtalk_error':'with_selector'(Error0, OtherSelector) in
                                    let HintMsg = #{#<67>(8,1,'integer',['unsigned'|['big']]),#<104>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<107>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<39>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<84>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<39>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<102>(8,1,'integer',['unsigned'|['big']]),#<121>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<104>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<120>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']])}# in
                                    let Error = call 'beamtalk_error':'with_hint'(Error1, HintMsg) in
                                    {'error', Error, State}
                            end
                    end
            end
    end


'method_table'/0 = fun () ->
    ~{'test' => 0, 'testLocal' => 0, 'testBlockParam' => 0, 'testBlockParamWhileFalse' => 0, 'testTimesRepeat' => 0, 'testTimesRepeatBlockParam' => 0, 'testToDo' => 0, 'testToDoBlockParam' => 0}~


'has_method'/1 = fun (Selector) ->
    call 'lists':'member'(Selector, ['test', 'testLocal', 'testBlockParam', 'testBlockParamWhileFalse', 'testTimesRepeat', 'testTimesRepeatBlockParam', 'testToDo', 'testToDoBlockParam'])

end
