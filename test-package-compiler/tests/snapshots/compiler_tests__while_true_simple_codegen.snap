---
source: test-package-compiler/tests/compiler_tests.rs
expression: core_erlang
---
module 'while_true_simple' ['start_link'/1, 'init'/1, 'handle_cast'/2, 'handle_call'/3, 'code_change'/3, 'terminate'/2, 'dispatch'/4, 'safe_dispatch'/3, 'method_table'/0, 'has_method'/1, 'spawn'/0, 'spawn'/1]
  attributes ['behaviour' = ['gen_server']]

'start_link'/1 = fun (InitArgs) ->
    call 'gen_server':'start_link'('while_true_simple', InitArgs, [])


'spawn'/0 = fun () ->
    case call 'gen_server':'start_link'('while_true_simple', ~{}~, []) of
        <{'ok', Pid}> when 'true' ->
            {'beamtalk_object', 'WhileTrueSimple', 'while_true_simple', Pid}
        <{'error', Reason}> when 'true' ->
            call 'erlang':'error'({'spawn_failed', Reason})
    end


'spawn'/1 = fun (InitArgs) ->
    case call 'gen_server':'start_link'('while_true_simple', InitArgs, []) of
        <{'ok', Pid}> when 'true' ->
            {'beamtalk_object', 'WhileTrueSimple', 'while_true_simple', Pid}
        <{'error', Reason}> when 'true' ->
            call 'erlang':'error'({'spawn_failed', Reason})
    end


'init'/1 = fun (InitArgs) ->
    let DefaultState = ~{
        '__class__' => 'WhileTrueSimple',
        '__class_mod__' => 'while_true_simple',
        '__methods__' => call 'while_true_simple':'method_table'()
    }~
    in let FinalState = call 'maps':'merge'(DefaultState, InitArgs)
    in {'ok', FinalState}


'handle_cast'/2 = fun (Msg, State) ->
    case Msg of
        <{Selector, Args, FuturePid}> when 'true' ->
            case call 'while_true_simple':'safe_dispatch'(Selector, Args, State) of
                <{'reply', Result, NewState}> when 'true' ->
                    let _Ignored = call 'erlang':'!'(FuturePid, {'resolve', Result})
                    in {'noreply', NewState}
                <{'error', Error, NewState}> when 'true' ->
                    let _Ignored = call 'erlang':'!'(FuturePid, {'reject', Error})
                    in {'noreply', NewState}
            end
    end


'handle_call'/3 = fun (Msg, _From, State) ->
    case Msg of
        <{Selector, Args}> when 'true' ->
            case call 'while_true_simple':'safe_dispatch'(Selector, Args, State) of
                <{'reply', Result, NewState}> when 'true' ->
                    {'reply', {'ok', Result}, NewState}
                <{'error', Error, NewState}> when 'true' ->
                    {'reply', {'error', Error}, NewState}
            end
    end


'code_change'/3 = fun (_OldVsn, State, _Extra) ->
    %% TODO: Add state migration logic
    {'ok', State}


'terminate'/2 = fun (Reason, State) ->
    %% Call terminate method if defined (Flavors pattern)
    let Self = call 'beamtalk_actor':'make_self'(State) in
    case call 'while_true_simple':'dispatch'('terminate', [Reason], Self, State) of
        <{'reply', _TermResult, _TermState}> when 'true' -> 'ok'
        <{'error', _TermError, _TermState2}> when 'true' -> 'ok'
        <_TermOther> when 'true' -> 'ok'
    end


'safe_dispatch'/3 = fun (Selector, Args, State) ->
    let Self = call 'beamtalk_actor':'make_self'(State) in
    try call 'while_true_simple':'dispatch'(Selector, Args, Self, State)
    of Result -> Result
    catch <Type, Error, _Stacktrace> -> {'error', {Type, Error}, State}


'dispatch'/4 = fun (Selector, Args, Self, State) ->
    case Selector of
        <'test'> when 'true' ->
            let Count = 0 in let Count = letrec '_Loop1'/0 = fun () -> let _CondFun2 = fun () -> call 'erlang':'<'(Count, 3) in case apply _CondFun2 () of <'true'> when 'true' -> let _BodyFun3 = fun () -> call 'erlang':'+'(Count, 1) in let _ = apply _BodyFun3 () in apply '_Loop1'/0 () <'false'> when 'true' -> 'nil' end in apply '_Loop1'/0 () in let _Result = Count in {'reply', _Result, State}
        <'testLocal'> when 'true' ->
            let X = 0 in let X = letrec '_Loop4'/0 = fun () -> let _CondFun5 = fun () -> call 'erlang':'<'(X, 5) in case apply _CondFun5 () of <'true'> when 'true' -> let _BodyFun6 = fun () -> call 'erlang':'+'(X, 1) in let _ = apply _BodyFun6 () in apply '_Loop4'/0 () <'false'> when 'true' -> 'nil' end in apply '_Loop4'/0 () in let _Result = X in {'reply', _Result, State}
        <'testBlockParam'> when 'true' ->
            let Result = let _Fun7 = fun (_x8) -> let _x8 = letrec '_Loop9'/0 = fun () -> let _CondFun10 = fun () -> call 'erlang':'<'(_x8, 5) in case apply _CondFun10 () of <'true'> when 'true' -> let _BodyFun11 = fun () -> call 'erlang':'+'(_x8, 1) in let _ = apply _BodyFun11 () in apply '_Loop9'/0 () <'false'> when 'true' -> 'nil' end in apply '_Loop9'/0 () in _x8 in apply _Fun7 (0) in let _Result = Result in {'reply', _Result, State}
        <'testBlockParamWhileFalse'> when 'true' ->
            let Result = let _Fun12 = fun (_n13) -> let _n13 = letrec '_Loop14'/0 = fun () -> let _CondFun15 = fun () -> call 'erlang':'=:='(_n13, 0) in case apply _CondFun15 () of <'false'> when 'true' -> let _BodyFun16 = fun () -> call 'erlang':'-'(_n13, 1) in let _ = apply _BodyFun16 () in apply '_Loop14'/0 () <'true'> when 'true' -> 'nil' end in apply '_Loop14'/0 () in _n13 in apply _Fun12 (5) in let _Result = Result in {'reply', _Result, State}
        <'testTimesRepeat'> when 'true' ->
            let Counter = 0 in let Counter = let _temp17 = 5 in letrec 'repeat'/1 = fun (I) -> case call 'erlang':'=<'(I, _temp17) of <'true'> when 'true' -> let _ = fun () -> call 'erlang':'+'(Counter, 1) in apply 'repeat'/1 (call 'erlang':'+'(I, 1)) <'false'> when 'true' -> 'nil' end in apply 'repeat'/1 (1) in let _Result = Counter in {'reply', _Result, State}
        <'testTimesRepeatBlockParam'> when 'true' ->
            let Result = let _Fun18 = fun (_n19) -> let _n19 = let _temp20 = 3 in letrec 'repeat'/1 = fun (I) -> case call 'erlang':'=<'(I, _temp20) of <'true'> when 'true' -> let _ = fun () -> call 'erlang':'+'(_n19, 10) in apply 'repeat'/1 (call 'erlang':'+'(I, 1)) <'false'> when 'true' -> 'nil' end in apply 'repeat'/1 (1) in _n19 in apply _Fun18 (5) in let _Result = Result in {'reply', _Result, State}
        <'testToDo'> when 'true' ->
            let Total = 0 in let Total = let _temp21 = 1 in let _temp22 = 10 in let _temp23 = fun (_n24) -> call 'erlang':'+'(Total, _n24) in letrec 'loop'/1 = fun (I) -> case call 'erlang':'=<'(I, _temp22) of <'true'> when 'true' -> let _ = apply _temp23 (I) in apply 'loop'/1 (call 'erlang':'+'(I, 1)) <'false'> when 'true' -> 'nil' end in apply 'loop'/1 (_temp21) in let _Result = Total in {'reply', _Result, State}
        <'testToDoBlockParam'> when 'true' ->
            let Result = let _Fun25 = fun (_x26) -> let Sum = 0 in let Sum = let _temp27 = _x26 in let _temp28 = 5 in let _temp29 = fun (_i30) -> call 'erlang':'+'(Sum, _i30) in letrec 'loop'/1 = fun (I) -> case call 'erlang':'=<'(I, _temp28) of <'true'> when 'true' -> let _ = apply _temp29 (I) in apply 'loop'/1 (call 'erlang':'+'(I, 1)) <'false'> when 'true' -> 'nil' end in apply 'loop'/1 (_temp27) in Sum in apply _Fun25 (1) in let _Result = Result in {'reply', _Result, State}
        <OtherSelector> when 'true' ->
            %% Try doesNotUnderstand:args: fallback (BT-29)
            let DnuSelector = 'doesNotUnderstand:args:' in
            let Methods = call 'maps':'get'('__methods__', State) in
            case call 'maps':'is_key'(DnuSelector, Methods) of
                <'true'> when 'true' ->
                    %% Call doesNotUnderstand:args: with [Selector, Args]
                    call 'while_true_simple':'dispatch'(DnuSelector, [OtherSelector, Args], Self, State)
                <'false'> when 'true' ->
                    %% No DNU handler - return #beamtalk_error{} record
                    let ClassName = call 'maps':'get'('__class__', State) in
                    let Error0 = call 'beamtalk_error':'new'('does_not_understand', ClassName) in
                    let Error1 = call 'beamtalk_error':'with_selector'(Error0, OtherSelector) in
                    let HintMsg = #{#<67>(8,1,'integer',['unsigned'|['big']]),#<104>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<107>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<39>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<84>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<39>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<102>(8,1,'integer',['unsigned'|['big']]),#<121>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<104>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<120>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']])}# in
                    let Error = call 'beamtalk_error':'with_hint'(Error1, HintMsg) in
                    {'error', Error, State}
            end
    end


'method_table'/0 = fun () ->
    ~{'test' => 0, 'testLocal' => 0, 'testBlockParam' => 0, 'testBlockParamWhileFalse' => 0, 'testTimesRepeat' => 0, 'testTimesRepeatBlockParam' => 0, 'testToDo' => 0, 'testToDoBlockParam' => 0}~


'has_method'/1 = fun (Selector) ->
    call 'lists':'member'(Selector, ['test', 'testLocal', 'testBlockParam', 'testBlockParamWhileFalse', 'testTimesRepeat', 'testTimesRepeatBlockParam', 'testToDo', 'testToDoBlockParam'])

end
