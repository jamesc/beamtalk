---
source: test-package-compiler/tests/compiler_tests.rs
expression: core_erlang
---
module 'boundary_deeply_nested' ['start_link'/1, 'init'/1, 'handle_cast'/2, 'handle_call'/3, 'code_change'/3, 'terminate'/2, 'dispatch'/4, 'safe_dispatch'/3, 'method_table'/0, 'has_method'/1, 'spawn'/0, 'spawn'/1, 'new'/0, 'new'/1, 'superclass'/0]
  attributes ['behaviour' = ['gen_server']]

'start_link'/1 = fun (InitArgs) ->
    call 'gen_server':'start_link'('boundary_deeply_nested', InitArgs, [])


'spawn'/0 = fun () ->
    case call 'gen_server':'start_link'('boundary_deeply_nested', ~{}~, []) of
        <{'ok', Pid}> when 'true' ->
            {'beamtalk_object', 'BoundaryDeeplyNested', 'boundary_deeply_nested', Pid}
        <{'error', Reason}> when 'true' ->
            call 'erlang':'error'({'spawn_failed', Reason})
    end


'spawn'/1 = fun (InitArgs) ->
    case call 'gen_server':'start_link'('boundary_deeply_nested', InitArgs, []) of
        <{'ok', Pid}> when 'true' ->
            {'beamtalk_object', 'BoundaryDeeplyNested', 'boundary_deeply_nested', Pid}
        <{'error', Reason}> when 'true' ->
            call 'erlang':'error'({'spawn_failed', Reason})
    end


'new'/0 = fun () ->
    let Error0 = call 'beamtalk_error':'new'('instantiation_error', 'Actor') in
    let Error1 = call 'beamtalk_error':'with_selector'(Error0, 'new') in
    let Error2 = call 'beamtalk_error':'with_hint'(Error1, #{#<85>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']])}#) in
    call 'erlang':'error'(Error2)

'new'/1 = fun (_InitArgs) ->
    let Error0 = call 'beamtalk_error':'new'('instantiation_error', 'Actor') in
    let Error1 = call 'beamtalk_error':'with_selector'(Error0, 'new:') in
    let Error2 = call 'beamtalk_error':'with_hint'(Error1, #{#<85>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<87>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<104>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']])}#) in
    call 'erlang':'error'(Error2)

'superclass'/0 = fun () -> 'nil'


'init'/1 = fun (InitArgs) ->
    let DefaultState = ~{
        '$beamtalk_class' => 'BoundaryDeeplyNested',
        '__class_mod__' => 'boundary_deeply_nested',
        '__methods__' => call 'boundary_deeply_nested':'method_table'()
    }~
    in let FinalState = call 'maps':'merge'(DefaultState, InitArgs)
    in {'ok', FinalState}


'handle_cast'/2 = fun (Msg, State) ->
    case Msg of
        <{Selector, Args, FuturePid}> when 'true' ->
            case call 'boundary_deeply_nested':'safe_dispatch'(Selector, Args, State) of
                <{'reply', Result, NewState}> when 'true' ->
                    let _Ignored = call 'erlang':'!'(FuturePid, {'resolve', Result})
                    in {'noreply', NewState}
                <{'error', Error, NewState}> when 'true' ->
                    let _Ignored = call 'erlang':'!'(FuturePid, {'reject', Error})
                    in {'noreply', NewState}
            end
    end


'handle_call'/3 = fun (Msg, _From, State) ->
    case Msg of
        <{Selector, Args}> when 'true' ->
            case call 'boundary_deeply_nested':'safe_dispatch'(Selector, Args, State) of
                <{'reply', Result, NewState}> when 'true' ->
                    {'reply', {'ok', Result}, NewState}
                <{'error', Error, NewState}> when 'true' ->
                    {'reply', {'error', Error}, NewState}
            end
    end


'code_change'/3 = fun (_OldVsn, State, _Extra) ->
    %% TODO: Add state migration logic
    {'ok', State}


'terminate'/2 = fun (Reason, State) ->
    %% Call terminate method if defined (Flavors pattern)
    let Self = call 'beamtalk_actor':'make_self'(State) in
    case call 'boundary_deeply_nested':'dispatch'('terminate', [Reason], Self, State) of
        <{'reply', _TermResult, _TermState}> when 'true' -> 'ok'
        <{'error', _TermError, _TermState2}> when 'true' -> 'ok'
        <_TermOther> when 'true' -> 'ok'
    end


'safe_dispatch'/3 = fun (Selector, Args, State) ->
    let Self = call 'beamtalk_actor':'make_self'(State) in
    try call 'boundary_deeply_nested':'dispatch'(Selector, Args, Self, State)
    of Result -> Result
    catch <Type, Error, _Stacktrace> -> {'error', {Type, Error}, State}


'dispatch'/4 = fun (Selector, Args, Self, State) ->
    case Selector of
        <'result4'> when 'true' ->
            let _Result = fun () -> fun () -> fun () -> fun () -> fun () -> 42 in {'reply', _Result, State}
        <'result5'> when 'true' ->
            let _seq1 = fun (_x2) -> fun () -> fun (_y3) -> fun () -> fun (_z4) -> call 'erlang':'+'(_x2, call 'erlang':'*'(_y3, _z4)) in let _Result = let _Receiver5 = call 'maps':'get'('object', State) in let _Pid6 = call 'erlang':'element'(4, _Receiver5) in let _ = let _Future7 = call 'beamtalk_future':'new'() in let _ = call 'beamtalk_actor':'async_send'(_Pid6, 'at:put:', [let _Receiver8 = call 'maps':'get'('a', State) in case case call 'erlang':'is_tuple'(_Receiver8) of <'true'> when 'true' -> case call 'erlang':'=='(call 'erlang':'tuple_size'(_Receiver8), 4) of <'true'> when 'true' -> call 'erlang':'=='(call 'erlang':'element'(1, _Receiver8), 'beamtalk_object') <_> when 'true' -> 'false' end <_> when 'true' -> 'false' end of <'true'> when 'true' -> let _IsClass11 = call 'beamtalk_object_class':'is_class_object'(_Receiver8) in case _IsClass11 of <'true'> when 'true' -> let _ClassPid12 = call 'erlang':'element'(4, _Receiver8) in call 'beamtalk_object_class':'class_send'(_ClassPid12, 'at:', [let _Receiver13 = call 'maps':'get'('b', State) in case case call 'erlang':'is_tuple'(_Receiver13) of <'true'> when 'true' -> case call 'erlang':'=='(call 'erlang':'tuple_size'(_Receiver13), 4) of <'true'> when 'true' -> call 'erlang':'=='(call 'erlang':'element'(1, _Receiver13), 'beamtalk_object') <_> when 'true' -> 'false' end <_> when 'true' -> 'false' end of <'true'> when 'true' -> let _IsClass16 = call 'beamtalk_object_class':'is_class_object'(_Receiver13) in case _IsClass16 of <'true'> when 'true' -> let _ClassPid17 = call 'erlang':'element'(4, _Receiver13) in call 'beamtalk_object_class':'class_send'(_ClassPid17, 'at:', [1]) <'false'> when 'true' -> let _Pid14 = call 'erlang':'element'(4, _Receiver13) in let _Future15 = call 'beamtalk_future':'new'() in let _ = call 'beamtalk_actor':'async_send'(_Pid14, 'at:', [1], _Future15) in _Future15 end <'false'> when 'true' -> call 'beamtalk_primitive':'send'(_Receiver13, 'at:', [1]) end]) <'false'> when 'true' -> let _Pid9 = call 'erlang':'element'(4, _Receiver8) in let _Future10 = call 'beamtalk_future':'new'() in let _ = call 'beamtalk_actor':'async_send'(_Pid9, 'at:', [let _Receiver18 = call 'maps':'get'('b', State) in case case call 'erlang':'is_tuple'(_Receiver18) of <'true'> when 'true' -> case call 'erlang':'=='(call 'erlang':'tuple_size'(_Receiver18), 4) of <'true'> when 'true' -> call 'erlang':'=='(call 'erlang':'element'(1, _Receiver18), 'beamtalk_object') <_> when 'true' -> 'false' end <_> when 'true' -> 'false' end of <'true'> when 'true' -> let _IsClass21 = call 'beamtalk_object_class':'is_class_object'(_Receiver18) in case _IsClass21 of <'true'> when 'true' -> let _ClassPid22 = call 'erlang':'element'(4, _Receiver18) in call 'beamtalk_object_class':'class_send'(_ClassPid22, 'at:', [1]) <'false'> when 'true' -> let _Pid19 = call 'erlang':'element'(4, _Receiver18) in let _Future20 = call 'beamtalk_future':'new'() in let _ = call 'beamtalk_actor':'async_send'(_Pid19, 'at:', [1], _Future20) in _Future20 end <'false'> when 'true' -> call 'beamtalk_primitive':'send'(_Receiver18, 'at:', [1]) end], _Future10) in _Future10 end <'false'> when 'true' -> call 'beamtalk_primitive':'send'(_Receiver8, 'at:', [let _Receiver23 = call 'maps':'get'('b', State) in case case call 'erlang':'is_tuple'(_Receiver23) of <'true'> when 'true' -> case call 'erlang':'=='(call 'erlang':'tuple_size'(_Receiver23), 4) of <'true'> when 'true' -> call 'erlang':'=='(call 'erlang':'element'(1, _Receiver23), 'beamtalk_object') <_> when 'true' -> 'false' end <_> when 'true' -> 'false' end of <'true'> when 'true' -> let _IsClass26 = call 'beamtalk_object_class':'is_class_object'(_Receiver23) in case _IsClass26 of <'true'> when 'true' -> let _ClassPid27 = call 'erlang':'element'(4, _Receiver23) in call 'beamtalk_object_class':'class_send'(_ClassPid27, 'at:', [1]) <'false'> when 'true' -> let _Pid24 = call 'erlang':'element'(4, _Receiver23) in let _Future25 = call 'beamtalk_future':'new'() in let _ = call 'beamtalk_actor':'async_send'(_Pid24, 'at:', [1], _Future25) in _Future25 end <'false'> when 'true' -> call 'beamtalk_primitive':'send'(_Receiver23, 'at:', [1]) end]) end, let _Receiver28 = call 'maps':'get'('x', State) in case case call 'erlang':'is_tuple'(_Receiver28) of <'true'> when 'true' -> case call 'erlang':'=='(call 'erlang':'tuple_size'(_Receiver28), 4) of <'true'> when 'true' -> call 'erlang':'=='(call 'erlang':'element'(1, _Receiver28), 'beamtalk_object') <_> when 'true' -> 'false' end <_> when 'true' -> 'false' end of <'true'> when 'true' -> let _IsClass31 = call 'beamtalk_object_class':'is_class_object'(_Receiver28) in case _IsClass31 of <'true'> when 'true' -> let _ClassPid32 = call 'erlang':'element'(4, _Receiver28) in call 'beamtalk_object_class':'class_send'(_ClassPid32, 'get:', [let _Receiver33 = call 'maps':'get'('y', State) in case case call 'erlang':'is_tuple'(_Receiver33) of <'true'> when 'true' -> case call 'erlang':'=='(call 'erlang':'tuple_size'(_Receiver33), 4) of <'true'> when 'true' -> call 'erlang':'=='(call 'erlang':'element'(1, _Receiver33), 'beamtalk_object') <_> when 'true' -> 'false' end <_> when 'true' -> 'false' end of <'true'> when 'true' -> let _IsClass36 = call 'beamtalk_object_class':'is_class_object'(_Receiver33) in case _IsClass36 of <'true'> when 'true' -> let _ClassPid37 = call 'erlang':'element'(4, _Receiver33) in call 'beamtalk_object_class':'class_send'(_ClassPid37, 'get:', [2]) <'false'> when 'true' -> let _Pid34 = call 'erlang':'element'(4, _Receiver33) in let _Future35 = call 'beamtalk_future':'new'() in let _ = call 'beamtalk_actor':'async_send'(_Pid34, 'get:', [2], _Future35) in _Future35 end <'false'> when 'true' -> call 'beamtalk_primitive':'send'(_Receiver33, 'get:', [2]) end]) <'false'> when 'true' -> let _Pid29 = call 'erlang':'element'(4, _Receiver28) in let _Future30 = call 'beamtalk_future':'new'() in let _ = call 'beamtalk_actor':'async_send'(_Pid29, 'get:', [let _Receiver38 = call 'maps':'get'('y', State) in case case call 'erlang':'is_tuple'(_Receiver38) of <'true'> when 'true' -> case call 'erlang':'=='(call 'erlang':'tuple_size'(_Receiver38), 4) of <'true'> when 'true' -> call 'erlang':'=='(call 'erlang':'element'(1, _Receiver38), 'beamtalk_object') <_> when 'true' -> 'false' end <_> when 'true' -> 'false' end of <'true'> when 'true' -> let _IsClass41 = call 'beamtalk_object_class':'is_class_object'(_Receiver38) in case _IsClass41 of <'true'> when 'true' -> let _ClassPid42 = call 'erlang':'element'(4, _Receiver38) in call 'beamtalk_object_class':'class_send'(_ClassPid42, 'get:', [2]) <'false'> when 'true' -> let _Pid39 = call 'erlang':'element'(4, _Receiver38) in let _Future40 = call 'beamtalk_future':'new'() in let _ = call 'beamtalk_actor':'async_send'(_Pid39, 'get:', [2], _Future40) in _Future40 end <'false'> when 'true' -> call 'beamtalk_primitive':'send'(_Receiver38, 'get:', [2]) end], _Future30) in _Future30 end <'false'> when 'true' -> call 'beamtalk_primitive':'send'(_Receiver28, 'get:', [let _Receiver43 = call 'maps':'get'('y', State) in case case call 'erlang':'is_tuple'(_Receiver43) of <'true'> when 'true' -> case call 'erlang':'=='(call 'erlang':'tuple_size'(_Receiver43), 4) of <'true'> when 'true' -> call 'erlang':'=='(call 'erlang':'element'(1, _Receiver43), 'beamtalk_object') <_> when 'true' -> 'false' end <_> when 'true' -> 'false' end of <'true'> when 'true' -> let _IsClass46 = call 'beamtalk_object_class':'is_class_object'(_Receiver43) in case _IsClass46 of <'true'> when 'true' -> let _ClassPid47 = call 'erlang':'element'(4, _Receiver43) in call 'beamtalk_object_class':'class_send'(_ClassPid47, 'get:', [2]) <'false'> when 'true' -> let _Pid44 = call 'erlang':'element'(4, _Receiver43) in let _Future45 = call 'beamtalk_future':'new'() in let _ = call 'beamtalk_actor':'async_send'(_Pid44, 'get:', [2], _Future45) in _Future45 end <'false'> when 'true' -> call 'beamtalk_primitive':'send'(_Receiver43, 'get:', [2]) end]) end], _Future7) in _Future7 in let _Future48 = call 'beamtalk_future':'new'() in let _ = call 'beamtalk_actor':'async_send'(_Pid6, 'at:put:', [let _Receiver49 = call 'maps':'get'('c', State) in case case call 'erlang':'is_tuple'(_Receiver49) of <'true'> when 'true' -> case call 'erlang':'=='(call 'erlang':'tuple_size'(_Receiver49), 4) of <'true'> when 'true' -> call 'erlang':'=='(call 'erlang':'element'(1, _Receiver49), 'beamtalk_object') <_> when 'true' -> 'false' end <_> when 'true' -> 'false' end of <'true'> when 'true' -> let _IsClass52 = call 'beamtalk_object_class':'is_class_object'(_Receiver49) in case _IsClass52 of <'true'> when 'true' -> let _ClassPid53 = call 'erlang':'element'(4, _Receiver49) in call 'beamtalk_object_class':'class_send'(_ClassPid53, 'at:', [let _Receiver54 = call 'maps':'get'('d', State) in case case call 'erlang':'is_tuple'(_Receiver54) of <'true'> when 'true' -> case call 'erlang':'=='(call 'erlang':'tuple_size'(_Receiver54), 4) of <'true'> when 'true' -> call 'erlang':'=='(call 'erlang':'element'(1, _Receiver54), 'beamtalk_object') <_> when 'true' -> 'false' end <_> when 'true' -> 'false' end of <'true'> when 'true' -> let _IsClass57 = call 'beamtalk_object_class':'is_class_object'(_Receiver54) in case _IsClass57 of <'true'> when 'true' -> let _ClassPid58 = call 'erlang':'element'(4, _Receiver54) in call 'beamtalk_object_class':'class_send'(_ClassPid58, 'at:', [3]) <'false'> when 'true' -> let _Pid55 = call 'erlang':'element'(4, _Receiver54) in let _Future56 = call 'beamtalk_future':'new'() in let _ = call 'beamtalk_actor':'async_send'(_Pid55, 'at:', [3], _Future56) in _Future56 end <'false'> when 'true' -> call 'beamtalk_primitive':'send'(_Receiver54, 'at:', [3]) end]) <'false'> when 'true' -> let _Pid50 = call 'erlang':'element'(4, _Receiver49) in let _Future51 = call 'beamtalk_future':'new'() in let _ = call 'beamtalk_actor':'async_send'(_Pid50, 'at:', [let _Receiver59 = call 'maps':'get'('d', State) in case case call 'erlang':'is_tuple'(_Receiver59) of <'true'> when 'true' -> case call 'erlang':'=='(call 'erlang':'tuple_size'(_Receiver59), 4) of <'true'> when 'true' -> call 'erlang':'=='(call 'erlang':'element'(1, _Receiver59), 'beamtalk_object') <_> when 'true' -> 'false' end <_> when 'true' -> 'false' end of <'true'> when 'true' -> let _IsClass62 = call 'beamtalk_object_class':'is_class_object'(_Receiver59) in case _IsClass62 of <'true'> when 'true' -> let _ClassPid63 = call 'erlang':'element'(4, _Receiver59) in call 'beamtalk_object_class':'class_send'(_ClassPid63, 'at:', [3]) <'false'> when 'true' -> let _Pid60 = call 'erlang':'element'(4, _Receiver59) in let _Future61 = call 'beamtalk_future':'new'() in let _ = call 'beamtalk_actor':'async_send'(_Pid60, 'at:', [3], _Future61) in _Future61 end <'false'> when 'true' -> call 'beamtalk_primitive':'send'(_Receiver59, 'at:', [3]) end], _Future51) in _Future51 end <'false'> when 'true' -> call 'beamtalk_primitive':'send'(_Receiver49, 'at:', [let _Receiver64 = call 'maps':'get'('d', State) in case case call 'erlang':'is_tuple'(_Receiver64) of <'true'> when 'true' -> case call 'erlang':'=='(call 'erlang':'tuple_size'(_Receiver64), 4) of <'true'> when 'true' -> call 'erlang':'=='(call 'erlang':'element'(1, _Receiver64), 'beamtalk_object') <_> when 'true' -> 'false' end <_> when 'true' -> 'false' end of <'true'> when 'true' -> let _IsClass67 = call 'beamtalk_object_class':'is_class_object'(_Receiver64) in case _IsClass67 of <'true'> when 'true' -> let _ClassPid68 = call 'erlang':'element'(4, _Receiver64) in call 'beamtalk_object_class':'class_send'(_ClassPid68, 'at:', [3]) <'false'> when 'true' -> let _Pid65 = call 'erlang':'element'(4, _Receiver64) in let _Future66 = call 'beamtalk_future':'new'() in let _ = call 'beamtalk_actor':'async_send'(_Pid65, 'at:', [3], _Future66) in _Future66 end <'false'> when 'true' -> call 'beamtalk_primitive':'send'(_Receiver64, 'at:', [3]) end]) end, let _Receiver69 = call 'maps':'get'('z', State) in case case call 'erlang':'is_tuple'(_Receiver69) of <'true'> when 'true' -> case call 'erlang':'=='(call 'erlang':'tuple_size'(_Receiver69), 4) of <'true'> when 'true' -> call 'erlang':'=='(call 'erlang':'element'(1, _Receiver69), 'beamtalk_object') <_> when 'true' -> 'false' end <_> when 'true' -> 'false' end of <'true'> when 'true' -> let _IsClass72 = call 'beamtalk_object_class':'is_class_object'(_Receiver69) in case _IsClass72 of <'true'> when 'true' -> let _ClassPid73 = call 'erlang':'element'(4, _Receiver69) in call 'beamtalk_object_class':'class_send'(_ClassPid73, 'get:', [let _Receiver74 = call 'maps':'get'('w', State) in case case call 'erlang':'is_tuple'(_Receiver74) of <'true'> when 'true' -> case call 'erlang':'=='(call 'erlang':'tuple_size'(_Receiver74), 4) of <'true'> when 'true' -> call 'erlang':'=='(call 'erlang':'element'(1, _Receiver74), 'beamtalk_object') <_> when 'true' -> 'false' end <_> when 'true' -> 'false' end of <'true'> when 'true' -> let _IsClass77 = call 'beamtalk_object_class':'is_class_object'(_Receiver74) in case _IsClass77 of <'true'> when 'true' -> let _ClassPid78 = call 'erlang':'element'(4, _Receiver74) in call 'beamtalk_object_class':'class_send'(_ClassPid78, 'get:', [4]) <'false'> when 'true' -> let _Pid75 = call 'erlang':'element'(4, _Receiver74) in let _Future76 = call 'beamtalk_future':'new'() in let _ = call 'beamtalk_actor':'async_send'(_Pid75, 'get:', [4], _Future76) in _Future76 end <'false'> when 'true' -> call 'beamtalk_primitive':'send'(_Receiver74, 'get:', [4]) end]) <'false'> when 'true' -> let _Pid70 = call 'erlang':'element'(4, _Receiver69) in let _Future71 = call 'beamtalk_future':'new'() in let _ = call 'beamtalk_actor':'async_send'(_Pid70, 'get:', [let _Receiver79 = call 'maps':'get'('w', State) in case case call 'erlang':'is_tuple'(_Receiver79) of <'true'> when 'true' -> case call 'erlang':'=='(call 'erlang':'tuple_size'(_Receiver79), 4) of <'true'> when 'true' -> call 'erlang':'=='(call 'erlang':'element'(1, _Receiver79), 'beamtalk_object') <_> when 'true' -> 'false' end <_> when 'true' -> 'false' end of <'true'> when 'true' -> let _IsClass82 = call 'beamtalk_object_class':'is_class_object'(_Receiver79) in case _IsClass82 of <'true'> when 'true' -> let _ClassPid83 = call 'erlang':'element'(4, _Receiver79) in call 'beamtalk_object_class':'class_send'(_ClassPid83, 'get:', [4]) <'false'> when 'true' -> let _Pid80 = call 'erlang':'element'(4, _Receiver79) in let _Future81 = call 'beamtalk_future':'new'() in let _ = call 'beamtalk_actor':'async_send'(_Pid80, 'get:', [4], _Future81) in _Future81 end <'false'> when 'true' -> call 'beamtalk_primitive':'send'(_Receiver79, 'get:', [4]) end], _Future71) in _Future71 end <'false'> when 'true' -> call 'beamtalk_primitive':'send'(_Receiver69, 'get:', [let _Receiver84 = call 'maps':'get'('w', State) in case case call 'erlang':'is_tuple'(_Receiver84) of <'true'> when 'true' -> case call 'erlang':'=='(call 'erlang':'tuple_size'(_Receiver84), 4) of <'true'> when 'true' -> call 'erlang':'=='(call 'erlang':'element'(1, _Receiver84), 'beamtalk_object') <_> when 'true' -> 'false' end <_> when 'true' -> 'false' end of <'true'> when 'true' -> let _IsClass87 = call 'beamtalk_object_class':'is_class_object'(_Receiver84) in case _IsClass87 of <'true'> when 'true' -> let _ClassPid88 = call 'erlang':'element'(4, _Receiver84) in call 'beamtalk_object_class':'class_send'(_ClassPid88, 'get:', [4]) <'false'> when 'true' -> let _Pid85 = call 'erlang':'element'(4, _Receiver84) in let _Future86 = call 'beamtalk_future':'new'() in let _ = call 'beamtalk_actor':'async_send'(_Pid85, 'get:', [4], _Future86) in _Future86 end <'false'> when 'true' -> call 'beamtalk_primitive':'send'(_Receiver84, 'get:', [4]) end]) end], _Future48) in _Future48 in {'reply', _Result, State}
        <OtherSelector> when 'true' ->
            %% BT-229/ADR 0005: Check extension registry before hierarchy walk
            let ExtLookup = try call 'beamtalk_extensions':'lookup'('BoundaryDeeplyNested', OtherSelector)
                of ExtLookupResult -> ExtLookupResult
                catch <_EType, _EReason, _EStack> -> 'not_found'
            in
            case ExtLookup of
                <{'ok', ExtFun, _ExtOwner}> when 'true' ->
                    let ExtResult = apply ExtFun(Args, Self) in
                    {'reply', ExtResult, State}
                <'not_found'> when 'true' ->
                    %% ADR 0006: Try hierarchy walk before DNU
                    case call 'beamtalk_dispatch':'super'(OtherSelector, Args, Self, State, 'BoundaryDeeplyNested') of
                        <{'reply', InheritedResult, InheritedState}> when 'true' ->
                            {'reply', InheritedResult, InheritedState}
                        <{'error', _DispatchError}> when 'true' ->
                            %% Not in hierarchy - try doesNotUnderstand:args: (BT-29)
                            let DnuSelector = 'doesNotUnderstand:args:' in
                            let Methods = call 'maps':'get'('__methods__', State) in
                            case call 'maps':'is_key'(DnuSelector, Methods) of
                                <'true'> when 'true' ->
                                    call 'boundary_deeply_nested':'dispatch'(DnuSelector, [OtherSelector, Args], Self, State)
                                <'false'> when 'true' ->
                                    %% No DNU handler - return #beamtalk_error{} record
                                    let ClassName = call 'maps':'get'('$beamtalk_class', State) in
                                    let Error0 = call 'beamtalk_error':'new'('does_not_understand', ClassName) in
                                    let Error1 = call 'beamtalk_error':'with_selector'(Error0, OtherSelector) in
                                    let HintMsg = #{#<67>(8,1,'integer',['unsigned'|['big']]),#<104>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<107>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<39>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<84>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<39>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<102>(8,1,'integer',['unsigned'|['big']]),#<121>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<104>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<120>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']])}# in
                                    let Error = call 'beamtalk_error':'with_hint'(Error1, HintMsg) in
                                    {'error', Error, State}
                            end
                    end
            end
    end


'method_table'/0 = fun () ->
    ~{'result4' => 0, 'result5' => 0}~


'has_method'/1 = fun (Selector) ->
    call 'lists':'member'(Selector, ['result4', 'result5'])

end
