---
source: test-package-compiler/tests/compiler_tests.rs
expression: core_erlang
---
module 'actor_state_mutation' ['init'/1, 'handle_cast'/2, 'handle_call'/3, 'code_change'/3, 'dispatch'/3, 'method_table'/0, 'spawn'/0, 'spawn'/1]
  attributes ['behaviour' = ['gen_server']]

'spawn'/0 = fun () ->
    case call 'gen_server':'start_link'('actor_state_mutation', ~{}~, []) of
        <{'ok', Pid}> when 'true' ->
            Pid
        <{'error', Reason}> when 'true' ->
            call 'erlang':'error'({'spawn_failed', Reason})
    end


'spawn'/1 = fun (InitArgs) ->
    case call 'gen_server':'start_link'('actor_state_mutation', InitArgs, []) of
        <{'ok', Pid}> when 'true' ->
            Pid
        <{'error', Reason}> when 'true' ->
            call 'erlang':'error'({'spawn_failed', Reason})
    end


'init'/1 = fun (InitArgs) ->
    let DefaultState = ~{
        '__class__' => 'ActorStateMutation',
        '__methods__' => call 'actor_state_mutation':'method_table'()
        , 'value' => 0
    }~
    in let FinalState = call 'maps':'merge'(DefaultState, InitArgs)
    in {'ok', FinalState}


'handle_cast'/2 = fun (Msg, State) ->
    case Msg of
        <{Selector, Args, FuturePid}> when 'true' ->
            case call 'actor_state_mutation':'dispatch'(Selector, Args, State) of
                <{'reply', Result, NewState}> when 'true' ->
                    let _Ignored = call 'erlang':'!'(FuturePid, {'resolved', Result})
                    in {'noreply', NewState}
            end
    end


'handle_call'/3 = fun (Msg, _From, State) ->
    case Msg of
        <{Selector, Args}> when 'true' ->
            case call 'actor_state_mutation':'dispatch'(Selector, Args, State) of
                <{'reply', Result, NewState}> when 'true' ->
                    {'reply', Result, NewState}
            end
    end


'code_change'/3 = fun (_OldVsn, State, _Extra) ->
    %% TODO: Add state migration logic
    {'ok', State}


'dispatch'/3 = fun (Selector, Args, State) ->
    case Selector of
        <'increment'> when 'true' ->
            let _Val1 = call 'erlang':'+'(call 'maps':'get'('value', State), 1) in let State1 = call 'maps':'put'('value', _Val1, State) in let _Result = call 'maps':'get'('value', State1) in {'reply', _Result, State1}
        <'addTwice'> when 'true' ->
            case Args of
                <[_n2]> when 'true' ->
                    let _Val3 = call 'erlang':'+'(call 'maps':'get'('value', State), _n2) in let State1 = call 'maps':'put'('value', _Val3, State) in let _Val4 = call 'erlang':'+'(call 'maps':'get'('value', State1), _n2) in let State2 = call 'maps':'put'('value', _Val4, State1) in let _Result = call 'maps':'get'('value', State2) in {'reply', _Result, State2}
                <_> when 'true' -> {'reply', {'error', 'bad_arity'}, State}
            end
        <'getValue'> when 'true' ->
            let _Result = call 'maps':'get'('value', State) in {'reply', _Result, State}
        <'setValue'> when 'true' ->
            case Args of
                <[_n5]> when 'true' ->
                    let _Val6 = _n5 in let State1 = call 'maps':'put'('value', _Val6, State) in let _Result = call 'maps':'get'('value', State1) in {'reply', _Result, State1}
                <_> when 'true' -> {'reply', {'error', 'bad_arity'}, State}
            end
        <_> when 'true' ->
            {'reply', {'error', 'does_not_understand'}, State}
    end


'method_table'/0 = fun () ->
    ~{'increment' => 0, 'addTwice' => 1, 'getValue' => 0, 'setValue' => 1}~

end
