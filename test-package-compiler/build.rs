// Copyright 2026 James Casey
// SPDX-License-Identifier: Apache-2.0

//! Build script to auto-generate test functions from test case directories.
//!
//! This script scans the `cases/` directory and generates a test function
//! for each subdirectory containing a `main.bt` file.

use std::env;
use std::fs;
use std::io::Write;
use std::path::Path;

fn main() {
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR not set");
    let cases_dir = Path::new(&manifest_dir).join("cases");

    // Watch the cases directory for changes
    println!("cargo:rerun-if-changed={}", cases_dir.display());

    // Find all test cases
    let mut test_cases = Vec::new();
    if cases_dir.exists() {
        for entry in fs::read_dir(&cases_dir)
            .unwrap_or_else(|e| panic!("Failed to read cases directory: {}", e))
        {
            let entry = entry.expect("Failed to read directory entry");
            let path = entry.path();

            if path.is_dir() {
                // Watch the test case subdirectory for changes
                println!("cargo:rerun-if-changed={}", path.display());

                let main_bt = path.join("main.bt");
                if main_bt.exists() {
                    // Watch the main.bt file for changes
                    println!("cargo:rerun-if-changed={}", main_bt.display());

                    let case_name_os = path
                        .file_name()
                        .unwrap_or_else(|| panic!("Test case path {:?} has no file name", path));
                    let case_name = case_name_os.to_string_lossy().into_owned();

                    // Validate that the case name is a valid Rust identifier component
                    if !case_name.chars().all(|c| c.is_alphanumeric() || c == '_') {
                        panic!(
                            "Test case name '{}' contains invalid characters. Use only alphanumeric characters and underscores.",
                            case_name
                        );
                    }

                    test_cases.push(case_name);
                }
            }
        }
    }

    // Sort test cases for consistent ordering
    test_cases.sort();

    // Generate test functions
    let out_dir = env::var("OUT_DIR").expect("OUT_DIR not set");
    let dest_path = Path::new(&out_dir).join("generated_tests.rs");
    let mut f = fs::File::create(&dest_path)
        .unwrap_or_else(|e| panic!("Failed to create generated_tests.rs: {}", e));

    writeln!(f, "// Auto-generated test functions").expect("Failed to write to generated_tests.rs");
    writeln!(f, "// Do not edit this file manually\n")
        .expect("Failed to write to generated_tests.rs");

    for case_name in &test_cases {
        // Generate lexer test
        writeln!(f, "#[test]").expect("Failed to write test");
        writeln!(f, "fn test_{}_lexer() {{", case_name).expect("Failed to write test");
        writeln!(f, "    test_lexer_snapshot(\"{}\");", case_name).expect("Failed to write test");
        writeln!(f, "}}\n").expect("Failed to write test");

        // Generate parser test
        writeln!(f, "#[test]").expect("Failed to write test");
        writeln!(f, "fn test_{}_parser() {{", case_name).expect("Failed to write test");
        writeln!(f, "    test_parser_snapshot(\"{}\");", case_name).expect("Failed to write test");
        writeln!(f, "}}\n").expect("Failed to write test");

        // Generate codegen test
        writeln!(f, "#[test]").expect("Failed to write test");
        writeln!(f, "fn test_{}_codegen() {{", case_name).expect("Failed to write test");
        writeln!(f, "    test_codegen_snapshot(\"{}\");", case_name).expect("Failed to write test");
        writeln!(f, "}}\n").expect("Failed to write test");

        // Generate compilation verification test
        writeln!(f, "#[test]").expect("Failed to write test");
        writeln!(f, "fn test_{}_compiles() {{", case_name).expect("Failed to write test");
        writeln!(f, "    test_codegen_compiles(\"{}\");", case_name).expect("Failed to write test");
        writeln!(f, "}}\n").expect("Failed to write test");
    }

    println!("Generated {} test cases", test_cases.len());
}
